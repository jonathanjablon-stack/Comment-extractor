<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Word Forensics Suite v5.2g</title>

<script defer src="./jszip.min.js"></script>
<script defer src="./xlsx.bundle.js"></script>
<script defer src="./FileSaver.min.js"></script>


  <style>
    :root{
      --primary:#0d6efd;
      --bg:#f8f9fa;
      --dark:#212529;
      --secondary:#6c757d;
      --border:#dee2e6;
    }
    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      margin:0;
      padding:15px;
      padding-bottom:55px;
      background:var(--bg);
      color:#333;
    }
    .container{
      background:#fff;
      padding:15px;
      border-radius:12px;
      box-shadow:0 4px 12px rgba(0,0,0,.08);
      overflow:hidden;
    }
    h1{
      margin:0 0 15px 0;
      font-size:18px;
      text-align:center;
      color:var(--dark);
      font-weight:800;
    }

    .drop-zone{
      border:2px dashed #cbd5e0;
      padding:40px 20px;
      text-align:center;
      color:#6c757d;
      border-radius:8px;
      background:#fff;
      cursor:pointer;
      margin-bottom:15px;
      transition:.2s;
      user-select:none;
    }
    .drop-zone.dragover{ background:#eef7ff; border-color:var(--primary); color:var(--primary); }

    #status{
      text-align:center;
      font-size:12px;
      margin-bottom:10px;
      font-weight:800;
      color:var(--secondary);
      min-height:18px;
    }
    #error-log{
      display:none;
      background:#ffe6e6;
      color:#721c24;
      padding:10px;
      font-size:11px;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      margin-top:10px;
      border:1px solid #f5c6cb;
      white-space:pre-wrap;
      border-radius:6px;
    }

    .tabs{
      display:none;
      overflow-x:auto;
      white-space:nowrap;
      margin-bottom:10px;
      border-bottom:1px solid var(--border);
      -webkit-overflow-scrolling:touch;
      padding-bottom:2px;
    }
    .tab-btn{
      display:inline-block;
      padding:10px 15px;
      background:none;
      border:none;
      font-size:13px;
      font-weight:700;
      color:#6c757d;
      border-bottom:3px solid transparent;
      cursor:pointer;
    }
    .tab-btn.active{ color:var(--primary); border-bottom-color:var(--primary); }

    .toolbar{
      display:none;
      gap:8px;
      flex-wrap:wrap;
      margin-bottom:12px;
      background:#e9ecef;
      padding:10px;
      border-radius:8px;
      align-items:center;
    }
    .btn{
      border:none;
      padding:11px 12px;
      font-size:12px;
      font-weight:800;
      border-radius:6px;
      color:#fff;
      cursor:pointer;
      text-align:center;
      white-space:nowrap;
      flex:1 1 140px;
    }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .btn-primary{ background:var(--primary); }
    .btn-success{ background:#198754; }
    .btn-warning{ background:#ffc107; color:#000; }
    .btn-danger{ background:#dc3545; }
    .btn-secondary{ background:#6c757d; }

    .view-section{ display:none; animation:fadeIn .2s; }
    @keyframes fadeIn{ from{opacity:0} to{opacity:1} }

    .table-wrap{
      overflow:auto;
      border:1px solid var(--border);
      border-radius:6px;
      max-height:62vh;
      background:#fff;
    }
    table{ width:100%; min-width:920px; border-collapse:collapse; font-size:12px; }
    th{
      background:var(--dark);
      color:#fff;
      position:sticky;
      top:0;
      z-index:10;
      padding:10px;
      text-align:left;
      white-space:nowrap;
      cursor:pointer;
    }
    th:hover{ background:#495057; }
    td{ padding:10px; border-bottom:1px solid #eee; vertical-align:top; }
    th.sort-asc::after{ content:" ‚ñ≤"; opacity:.85; }
    th.sort-desc::after{ content:" ‚ñº"; opacity:.85; }

    .filter-row th{
      background:#e9ecef;
      padding:5px;
      cursor:default;
      position:sticky;
      top:37px;
      z-index:9;
    }
    .filter-input{
      width:100%;
      padding:5px;
      border:1px solid #ced4da;
      border-radius:4px;
      font-size:11px;
      box-sizing:border-box;
      background:#fff;
    }

    .editable{ background:#fff8e1; border:1px solid transparent; }
    .editable:focus{ outline:2px solid var(--primary); background:#fff; border-color:#ccc; }

    .cell-input{
      width:100%;
      box-sizing:border-box;
      padding:6px;
      border:1px solid #ced4da;
      border-radius:4px;
      font-size:11px;
      background:#fff;
    }
    .cell-input.editish{ background:#fff8e1; }

    .badge{
      padding:3px 6px;
      border-radius:3px;
      color:#fff;
      font-size:10px;
      display:inline-block;
      min-width:44px;
      text-align:center;
    }
    .bg-com{ background:#17a2b8; }
    .bg-ins{ background:#28a745; }
    .bg-del{ background:#dc3545; }
    .bg-hi{ background:#dc3545; }
    .bg-med{ background:#ffc107; color:#000; }
    .bg-lo{ background:#198754; }

    
    .doc-topbar{
      display:flex;
      gap:8px;
      padding:10px;
      background:#f1f3f5;
      border:1px solid #ccc;
      border-bottom:none;
      border-radius:6px 6px 0 0;
      align-items:center;
      flex-wrap:wrap;
    }
    .doc-topbar select, .doc-topbar input{
      padding:8px;
      border:1px solid #ccc;
      border-radius:6px;
      font-size:12px;
      background:#fff;
      flex:1 1 240px;
      min-width:170px;
    }
    .doc-topbar .mini{
      width:auto;
      flex:0 0 auto;
      padding:8px 10px;
      border-radius:6px;
      border:none;
      font-weight:900;
      cursor:pointer;
      background:#6c757d;
      color:#fff;
    }
    .doc-view-wrapper{
      display:flex;
      flex-direction:column;
      height:66vh;
      border:1px solid #ccc;
      border-radius:0 0 6px 6px;
      overflow:hidden;
      background:#fff;
    }
    .doc-content{
      flex:1;
      padding:15px;
      overflow-y:auto;
      background:#fff;
      font-family:'Times New Roman',serif;
      font-size:14px;
      line-height:1.6;
    }
    .doc-sidebar{
      height:170px;
      overflow-y:auto;
      background:#f8f9fa;
      border-top:1px solid #ccc;
      padding:10px;
    }
    .doc-ins{ background:#d4edda; border-bottom:2px solid #28a745; cursor:pointer; text-decoration:none; }
    .doc-del{ background:#f8d7da; text-decoration:line-through; color:#721c24; cursor:pointer; }
    .doc-com{ background:#fff3cd; border-bottom:2px solid #ffc107; cursor:pointer; }
    .comment-card{
      background:#fff;
      border:1px solid #ddd;
      padding:8px;
      margin-bottom:8px;
      border-radius:4px;
      font-size:11px;
      cursor:pointer;
      user-select:none;
    }
    .active-card{ border-left:4px solid var(--primary); background:#eef7ff; }

    
    .ghost-render{
      height:35vh;
      overflow-y:auto;
      padding:15px;
      border:1px solid #ccc;
      margin-bottom:10px;
      font-family:serif;
      background:#fff;
      border-radius:4px;
    }
    .ghost-render p{ padding:8px 6px; border-bottom:1px solid #eee; margin:0; }
    .ghost-toolbar{ background:#f8f9fa; padding:15px; border-radius:6px; border:1px solid #ddd; display:none; }
    .row-inline{ display:flex; gap:8px; }
    .row-inline > *{ flex:1; }
    .tiny{ font-size:11px; opacity:.8; margin-top:4px; }

    .flash-target{ animation:flash 2s linear 1; background:yellow!important; }
    @keyframes flash{ 0%{background:yellow} 50%{background:orange} 100%{background:yellow} }

    
    .modal{
      display:none;
      position:fixed;
      top:0; left:0;
      width:100%; height:100%;
      background:rgba(0,0,0,.5);
      z-index:999;
    }
    .modal-content{
      background:#fff;
      margin:10vh auto;
      padding:18px;
      width:92%;
      max-width:520px;
      border-radius:10px;
      box-shadow:0 5px 15px rgba(0,0,0,.3);
    }
    .form-row{ margin-bottom:12px; }
    .form-row label{ display:block; margin-bottom:6px; font-size:12px; font-weight:900; }
    input,select,textarea{
      width:100%;
      padding:10px;
      box-sizing:border-box;
      border:1px solid #ccc;
      border-radius:6px;
      font-size:12px;
      background:#fff;
    }
  
    
    .doc-table{
      width:100%;
      border-collapse:collapse;
      margin:10px 0;
      table-layout:fixed;
    }
    .doc-table td{
      border:1px solid #d9dde3;
      padding:8px 10px;
      vertical-align:top;
      word-break:break-word;
    }
    .doc-table p{
      margin:0 0 8px 0;
    }
    .doc-table p:last-child{
      margin-bottom:0;
    }

  </style>
</head>

<body>
  <div class="container">
    <h1>Word Forensics Suite v5.2g</h1>

    <div id="drop-zone" class="drop-zone" role="button" tabindex="0" aria-label="Open DOCX">
      üìÑ Tap to Open .docx<br><span style="font-size:11px; opacity:0.8;">or drag & drop here</span>
    </div>
    <input type="file" id="file-input" accept=".docx" style="display:none;" />

    <div id="status"></div>
    <div id="error-log"></div>

    <div class="tabs" id="tabs">
      <button class="tab-btn active" data-tab="comments">Comments</button>
      <button class="tab-btn" data-tab="revisions">Changes</button>
      <button class="tab-btn" data-tab="all">All Activity</button>
      <button class="tab-btn" data-tab="parts">Parts</button>
      <button class="tab-btn" data-tab="relationships">Relationships</button>
      <button class="tab-btn" data-tab="forensics">Forensics</button>
      <button class="tab-btn" data-tab="ghost">Ghost Writer</button>
      <button class="tab-btn" data-tab="regex">Regex Replace</button>
      <button class="tab-btn" data-tab="meta">Metadata</button>
    </div>

    <div class="toolbar" id="toolbar">
      <button class="btn btn-warning" id="btn-batch-tools">Batch Tools</button>
      <button class="btn btn-primary" id="btn-save">Save Docx</button>
      <button class="btn btn-secondary" id="btn-copy">Copy Table</button>
      <button class="btn btn-success" id="btn-export">Export XLSX</button>
      <button class="btn btn-danger" id="btn-reset">Reset</button>
    </div>

    
    <div id="view-table" class="view-section table-wrap">
      <table id="data-table">
        <thead id="data-head"></thead>
        <tbody id="data-body"></tbody>
      </table>
    </div>

    
    <div id="view-parts" class="view-section">
      <div class="doc-topbar">
        <select id="part-select" aria-label="Part selector"></select>
        <input id="part-filter" type="text" placeholder="Filter sidebar (quick)" aria-label="Sidebar filter" />
        <button class="mini" id="btn-clear-selection" title="Clear selections">Clear Sel</button>
      </div>
      <div class="doc-view-wrapper">
        <div class="doc-content" id="doc-content"></div>
        <div class="doc-sidebar" id="doc-sidebar"></div>
      </div>
      <div class="tiny" style="margin-top:8px;">
        Parts load on demand to avoid long startup freezes. Your export buttons still work here: they export the sidebar list for this part.
      </div>
    </div>

    
    <div id="view-rel" class="view-section table-wrap">
      <table id="rel-table">
        <thead id="rel-head"></thead>
        <tbody id="rel-body"></tbody>
      </table>
    </div>

    
    <div id="view-forensics" class="view-section table-wrap">
      <div style="padding:15px; text-align:center; background:#f1f3f5;">
        <button class="btn btn-primary" style="width:auto; padding:10px 20px; flex:0 0 auto;" id="btn-scan">
          üîç Click to Run Deep Scan
        </button>
      </div>
      <table id="forensics-table">
        <thead id="forensics-head"></thead>
        <tbody id="forensics-body"></tbody>
      </table>
    </div>

    
    <div id="view-ghost" class="view-section">
      <div class="ghost-render" id="ghost-render"></div>
      <div class="ghost-toolbar" id="ghost-tools">
        <div style="font-size:11px; margin-bottom:5px; color:#666;">
          Selected: <b id="ghost-sel-text" style="color:#000;"></b>
        </div>
        <input type="text" id="ghost-replace" placeholder="Replacement Text (Empty = Delete)">
        <div class="row-inline" style="margin-top:6px;">
          <input type="text" id="ghost-auth" placeholder="Author">
          <input type="datetime-local" id="ghost-date">
        </div>
        <button class="btn btn-warning" style="width:100%; margin-top:10px; flex:1;" id="btn-inject">Inject Revision</button>
      </div>
      <div style="text-align:center; color:#999; padding:20px; font-size:12px;" id="ghost-hint">
        Highlight text above to edit
      </div>
      <div class="tiny" style="margin-top:8px;">Export/Copy is disabled on this tab (there‚Äôs no table).</div>
    </div>


    
    <div id="view-regex" class="view-section">
      <div class="doc-topbar" style="border-radius:6px; border-bottom:1px solid #ccc;">
        <input id="rx-pattern" type="text" placeholder="Regex pattern (no / /)" aria-label="Regex pattern" />
        <input id="rx-replace" type="text" placeholder="Replacement" aria-label="Replacement" />
        <select id="rx-scope" aria-label="Scope">
          <option value="main">Main document only</option>
          <option value="active">Current part only</option>
          <option value="loaded">All loaded parts</option>
          <option value="all">All parts (will load headers/footers/etc.)</option>
        </select>
        <label style="display:flex; align-items:center; gap:6px; font-weight:900; font-size:12px; flex:0 0 auto;">
          <input type="checkbox" id="rx-i" /> i
        </label>
        <label style="display:flex; align-items:center; gap:6px; font-weight:900; font-size:12px; flex:0 0 auto;">
          <input type="checkbox" id="rx-m" /> m
        </label>
        <label style="display:flex; align-items:center; gap:6px; font-weight:900; font-size:12px; flex:0 0 auto;">
          <input type="checkbox" id="rx-s" /> s
        </label>
        <button class="mini" id="btn-rx-run" title="Run replace (text nodes only)">Run</button>
        <button class="mini" id="btn-rx-clear" title="Clear results">Clear</button>
      </div>

      <div class="tiny" style="margin:8px 0 10px 0;">
        This operates on <b>text only</b> (w:t and w:delText) and does not remove or rewrite XML tags.
        It may miss patterns that span multiple Word runs.
      </div>

      <div class="table-wrap">
        <table id="rx-table">
          <thead id="rx-head"></thead>
          <tbody id="rx-body"></tbody>
        </table>
      </div>
    </div>

    
    <div id="view-meta" class="view-section">
      <div style="padding:15px;">
        <h3 style="margin:0 0 10px 0;">Core Properties</h3>
        <div class="form-row"><label>Author</label><input type="text" id="meta-creator"></div>
        <div class="form-row"><label>Modified By</label><input type="text" id="meta-lastMod"></div>
        <h3 style="margin:14px 0 10px 0;">App Stats</h3>
        <div class="form-row"><label>Total Minutes</label><input type="number" id="meta-time"></div>
        <div class="form-row"><label>Revisions</label><input type="number" id="meta-revision"></div>
        <button class="btn btn-danger" style="width:100%; margin-top:10px; flex:1;" id="btn-wipe">üßΩ Wipe All Metadata</button>
      </div>
      <div class="tiny" style="margin-top:8px;">Export/Copy is disabled on this tab (there‚Äôs no table).</div>
    </div>
  </div>

  
  <div id="batchToolsModal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <h3 style="margin:0 0 12px 0;">Global Batch Tools</h3>

      <div class="form-row">
        <label>Scope</label>
        <select id="batch-scope">
          <option value="all">All items</option>
          <option value="filtered">Filtered (current table)</option>
          <option value="selected">Selected (checkboxes)</option>
        </select>
        <div class="tiny">‚ÄúFiltered‚Äù respects your current Comments/Changes/All mode + filters.</div>
      </div>

      <div class="form-row">
        <label>Part</label>
        <select id="batch-part">
          <option value="*">All parts</option>
        </select>
      </div>

      <div class="form-row">
        <label>Types</label>
        <div class="row-inline">
          <label style="font-weight:800;"><input type="checkbox" id="bt-com" checked> Comments</label>
          <label style="font-weight:800;"><input type="checkbox" id="bt-ins" checked> Insertions</label>
          <label style="font-weight:800;"><input type="checkbox" id="bt-del" checked> Deletions</label>
        </div>
      </div>

      <div class="form-row">
        <label>Operation</label>
        <select id="batch-op">
          <option value="setAuthor">Set Author</option>
          <option value="replaceAuthor">Replace Author</option>
          <option value="setDate">Set Date/Time</option>
          <option value="sequentialDate">Sequential Date/Time</option>
          <option value="shiftDate">Shift Date/Time</option>
        </select>
      </div>

      <div class="form-row" id="row-author">
        <label>Author</label>
        <input type="text" id="batch-author" placeholder="e.g., Author">
      </div>

      
      <div class="form-row" id="row-replace">
        <label>Replace Author</label>
        <div class="row-inline">
          <select id="batch-from-author" aria-label="From author"></select>
          <input type="text" id="batch-to-author" placeholder="To (new author name)" aria-label="To author">
        </div>
      </div>


      <div class="form-row" id="row-date">
        <label>Date/Time</label>
        <input type="datetime-local" id="batch-dt">
      </div>

      <div class="form-row" id="row-seq">
        <label>Sequential</label>
        <div class="row-inline">
          <input type="datetime-local" id="batch-seq-start">
          <input type="number" id="batch-seq-step" value="5" min="0" step="1" placeholder="Step minutes">
        </div>
        <div class="tiny">Applies in current visible order for ‚ÄúFiltered‚Äù; otherwise by Part then Pg then ID.</div>
      </div>

      <div class="form-row" id="row-shift">
        <label>Shift</label>
        <div class="row-inline">
          <input type="number" id="batch-shift-amt" value="60" step="1">
          <select id="batch-shift-unit">
            <option value="minutes">minutes</option>
            <option value="hours">hours</option>
            <option value="days">days</option>
          </select>
        </div>
        <div class="tiny">Only shifts items that already have a date.</div>
      </div>

      <div style="text-align:right; display:flex; gap:10px; margin-top:10px;">
        <button class="btn btn-secondary" id="btn-bt-cancel" style="flex:1;">Cancel</button>
        <button class="btn btn-warning" id="btn-bt-apply" style="flex:1;">Apply</button>
      </div>
    </div>
  </div>

  <script>
    window.onerror = function (msg, url, line, col, err) {
      const d = document.getElementById("error-log");
      d.style.display = "block";
      const detail = err && err.stack ? err.stack : String(msg);
      d.innerText += `ERR: ${detail} (Line ${line}${col ? ":" + col : ""})
`;
      return false;
    };

    const W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
    const XML_NS = "http://www.w3.org/XML/1998/namespace";

    let zipObj = null;
    let originalFileName = "";

    let mainDocXml = null;
    let coreXmlDoc = null;
    let appXmlDoc = null;
    let commentsXmlDoc = null;
    let metaDirty = false;

    const partsIndex = new Map();
    let activePartPath = "word/document.xml";

    function markPartDirty(path) {
      const m = partsIndex.get(path);
      if (!m) return;
      m.dirty = true;
      partsIndex.set(path, m);
    }

    const items = new Map();
    const selectedUids = new Set();

    let relationshipsBuilt = false;
    let relationshipsData = [];

    let forensicsData = [];

    let regexChanges = [];
    let pendingGlobalMetaOps = [];
    let regexHeadBuilt = false;

    let ghostReady = false;
    let ghostParagraphs = [];
    let ghostSelIdx = -1;
    let nextChangeId = 1;

    let currentTab = "all";
    let activityMode = "all";

    const tableState = {
      main: { sortCol: "pg", dir: 1, filters: {} },
      rel: { sortCol: "riskRank", dir: 1, filters: {} },
      forensics: { sortCol: "path", dir: 1, filters: {} },
      regex: { sortCol: "pg", dir: 1, filters: {} },
    };

    const dom = {
      drop: document.getElementById("drop-zone"),
      file: document.getElementById("file-input"),
      status: document.getElementById("status"),
      error: document.getElementById("error-log"),

      tabs: document.getElementById("tabs"),
      toolbar: document.getElementById("toolbar"),

      btnCopy: document.getElementById("btn-copy"),
      btnExport: document.getElementById("btn-export"),

      viewTable: document.getElementById("view-table"),
      tableHead: document.getElementById("data-head"),
      tableBody: document.getElementById("data-body"),

      viewParts: document.getElementById("view-parts"),
      partSelect: document.getElementById("part-select"),
      partFilter: document.getElementById("part-filter"),
      docContent: document.getElementById("doc-content"),
      docSidebar: document.getElementById("doc-sidebar"),

      viewRel: document.getElementById("view-rel"),
      relHead: document.getElementById("rel-head"),
      relBody: document.getElementById("rel-body"),

      viewForensics: document.getElementById("view-forensics"),
      forHead: document.getElementById("forensics-head"),
      forBody: document.getElementById("forensics-body"),

      viewRegex: document.getElementById("view-regex"),
      rxPattern: document.getElementById("rx-pattern"),
      rxReplace: document.getElementById("rx-replace"),
      rxScope: document.getElementById("rx-scope"),
      rxI: document.getElementById("rx-i"),
      rxM: document.getElementById("rx-m"),
      rxS: document.getElementById("rx-s"),
      rxHead: document.getElementById("rx-head"),
      rxBody: document.getElementById("rx-body"),

      viewGhost: document.getElementById("view-ghost"),
      ghostRender: document.getElementById("ghost-render"),
      ghostTools: document.getElementById("ghost-tools"),
      ghostHint: document.getElementById("ghost-hint"),
      ghostSelText: document.getElementById("ghost-sel-text"),
      ghostReplace: document.getElementById("ghost-replace"),
      ghostAuth: document.getElementById("ghost-auth"),
      ghostDate: document.getElementById("ghost-date"),

      viewMeta: document.getElementById("view-meta"),
      metaCreator: document.getElementById("meta-creator"),
      metaLastMod: document.getElementById("meta-lastMod"),
      metaTime: document.getElementById("meta-time"),
      metaRevision: document.getElementById("meta-revision"),

      btModal: document.getElementById("batchToolsModal"),
      btScope: document.getElementById("batch-scope"),
      btPart: document.getElementById("batch-part"),
      btCom: document.getElementById("bt-com"),
      btIns: document.getElementById("bt-ins"),
      btDel: document.getElementById("bt-del"),
      btOp: document.getElementById("batch-op"),
      btAuthor: document.getElementById("batch-author"),
      btFromAuthor: document.getElementById("batch-from-author"),
      btToAuthor: document.getElementById("batch-to-author"),
      btDt: document.getElementById("batch-dt"),
      btSeqStart: document.getElementById("batch-seq-start"),
      btSeqStep: document.getElementById("batch-seq-step"),
      btShiftAmt: document.getElementById("batch-shift-amt"),
      btShiftUnit: document.getElementById("batch-shift-unit"),
    };

    const btRows = {
      author: document.getElementById("row-author"),
      replace: document.getElementById("row-replace"),
      date: document.getElementById("row-date"),
      seq: document.getElementById("row-seq"),
      shift: document.getElementById("row-shift"),
    };

    function setStatus(text, ok = true) {
      dom.status.textContent = text;
      dom.status.style.color = ok ? "green" : "crimson";
    }

    function clearErrorLog() {
      dom.error.style.display = "none";
      dom.error.textContent = "";
    }

    function isParserError(xmldoc) {
      const pe = xmldoc.getElementsByTagName("parsererror");
      return pe && pe.length > 0;
    }

    function qAll(node, localName) {
      if (!node) return [];
      if (node.getElementsByTagNameNS) return Array.from(node.getElementsByTagNameNS("*", localName));
      return Array.from(node.getElementsByTagName("w:" + localName));
    }

    function attrW(node, name) {
      if (!node) return "";
      return node.getAttribute("w:" + name) || node.getAttribute(name) || "";
    }

    function setAttrW(node, name, value) {
      if (!node) return;
      try { node.setAttributeNS(W_NS, "w:" + name, value); }
      catch { node.setAttribute("w:" + name, value); }
    }

    function setAttrXmlSpacePreserve(node, text) {
      if (!node) return;
      if (typeof text === "string" && (/^\s/.test(text) || /\s$/.test(text) || /\s{2,}/.test(text))) {
        try { node.setAttributeNS(XML_NS, "xml:space", "preserve"); }
        catch { node.setAttribute("xml:space", "preserve"); }
      }
    }

    function escapeRegExp(s) {
      return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function escapeXmlAttr(s) {
      return String(s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&apos;");
    }


    function unescapeXmlAttr(s) {
      return String(s || "")
        .replace(/&quot;/g, '"')
        .replace(/&apos;/g, "'")
        .replace(/&gt;/g, ">")
        .replace(/&lt;/g, "<")
        .replace(/&amp;/g, "&");
    }

    // Applies a safe author patch directly to the raw XML string. This intentionally avoids
    // DOM re-serialization so we don't trigger Word's "formatting changed" churn (e.g., list numbering).
    function patchAuthorAttrsInXml(xml, fromRaw, to) {
      if (!xml) return xml;
      const toVal = escapeXmlAttr(String(to == null ? "" : to).trim());
      const from = (fromRaw === "__blank__") ? "" : String(fromRaw || "").trim();
      const fromLC = from.toLowerCase();

      return xml.replace(/\bw:author\s*=\s*(["'])(.*?)(\1)/g, (m, q, val) => {
        const cur = unescapeXmlAttr(val);
        const curLC = String(cur || "").trim().toLowerCase();
        const match = (fromRaw === "__blank__") ? (curLC === "") : (curLC === fromLC);
        if (!match) return m;
        return m.replace(val, toVal);
      });
    }

    function upsertAttrInStartTag(startTag, attrName, value) {
      const v = escapeXmlAttr(value == null ? "" : value);
      const a = escapeRegExp(attrName);
      const re = new RegExp("\\s" + a + "\\s*=\\s*([\"'])([^\"']*)\\1");
      if (re.test(startTag)) {
        return startTag.replace(re, " " + attrName + '="' + v + '"');
      }
      return startTag + " " + attrName + '="' + v + '"';
    }

    function patchRevisionAttrsInXml(xml, type, id, author, date) {
      if (!xml) return xml;
      const tag = (type === "ins") ? "w:ins" : "w:del";
      const idEsc = escapeRegExp(String(id));
      const re = new RegExp("<" + tag + "\\b[^>]*\\bw:id=([\"'])" + idEsc + "\\1[^>]*\\/?>", "g");

      return xml.replace(re, (full) => {
        const selfClosing = /\/>$/.test(full);
        let start = full.slice(0, selfClosing ? -2 : -1); // drop > or />
        start = upsertAttrInStartTag(start, "w:author", author || "");
        if (date) start = upsertAttrInStartTag(start, "w:date", date);
        return start + (selfClosing ? "/>" : ">");
      });
    }

    function toDatetimeLocal(iso) {
      if (!iso) return "";
      try {
        const d = new Date(iso);
        if (isNaN(d.getTime())) return "";
        const pad = n => String(n).padStart(2, "0");
        return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
      } catch { return ""; }
    }

    function fromDatetimeLocal(val) {
      if (!val) return "";
      const d = new Date(val);
      if (isNaN(d.getTime())) return "";
      return d.toISOString();
    }

    function safeSnippet(s, n = 60) {
      const t = String(s || "");
      return t.length > n ? t.slice(0, n) + "‚Ä¶" : t;
    }

    function stableSort(arr, cmp) {
      return arr.map((v, i) => ({ v, i }))
        .sort((a, b) => cmp(a.v, b.v) || (a.i - b.i))
        .map(x => x.v);
    }

    function partLabel(path) {
      if (path === "word/document.xml") return "Main Document";
      const mH = (path || "").match(/^word\/header(\d+)\.xml$/i);
      if (mH) return "Header " + mH[1];
      const mF = (path || "").match(/^word\/footer(\d+)\.xml$/i);
      if (mF) return "Footer " + mF[1];
      if (path === "word/footnotes.xml") return "Footnotes";
      if (path === "word/endnotes.xml") return "Endnotes";
      return (path || "").split("/").pop() || path || "";
    }

    function normalizePath(baseDir, target) {
      let t = target || "";
      if (t.startsWith("/")) t = t.slice(1);
      const raw = (baseDir || "") + t;
      const parts = raw.split("/").filter(x => x.length);
      const out = [];
      for (const p of parts) {
        if (p === ".") continue;
        if (p === "..") out.pop();
        else out.push(p);
      }
      return out.join("/");
    }

    function yieldToUI() {
      return new Promise(res => setTimeout(res, 0));
    }

    function buildPartsIndex(zip) {
      partsIndex.clear();
      partsIndex.set("word/document.xml", { path:"word/document.xml", label:"Main Document", loaded:false, xmlDoc:null });

      zip.forEach((path) => {
        const p = path.toLowerCase();
        if (p.match(/^word\/header\d+\.xml$/) ||
            p.match(/^word\/footer\d+\.xml$/) ||
            p === "word/footnotes.xml" ||
            p === "word/endnotes.xml") {
          partsIndex.set(path, { path, label: partLabel(path), loaded:false, xmlDoc:null });
        }
      });
    }

    function getPartOptions() {
      const arr = Array.from(partsIndex.keys());
      arr.sort((a,b) => partLabel(a).localeCompare(partLabel(b)));
      const idx = arr.indexOf("word/document.xml");
      if (idx > 0) { arr.splice(idx,1); arr.unshift("word/document.xml"); }
      return arr;
    }

    function populatePartSelects() {
      dom.partSelect.textContent = "";
      const opts = getPartOptions();
      for (const p of opts) {
        const opt = document.createElement("option");
        opt.value = p;
        opt.textContent = partLabel(p);
        dom.partSelect.appendChild(opt);
      }
      dom.partSelect.value = activePartPath;

      dom.btPart.textContent = "";
      const optAll = document.createElement("option");
      optAll.value = "*";
      optAll.textContent = "All parts";
      dom.btPart.appendChild(optAll);
      for (const p of opts) {
        const opt = document.createElement("option");
        opt.value = p;
        opt.textContent = partLabel(p);
        dom.btPart.appendChild(opt);
      }
    }

    async function ensurePartLoaded(path) {
      const meta = partsIndex.get(path);
      if (!meta || meta.loaded) return meta;
      if (!zipObj || !zipObj.file(path)) throw new Error("Missing part: " + path);

      setStatus("Loading part: " + partLabel(path) + "‚Ä¶", true);
      const s = await zipObj.file(path).async("string");
      const doc = new DOMParser().parseFromString(s, "text/xml");
      if (isParserError(doc)) throw new Error("Failed to parse " + path);

      meta.loaded = true;
      meta.xmlDoc = doc;
      meta.original = s;
      meta.dirty = false;
      partsIndex.set(path, meta);
      if (path === "word/document.xml") mainDocXml = doc;

      rebuildRevisionsAndAnchorsFromLoadedParts();

      setStatus("Ready.", true);
      return meta;
    }

    function mapContext(xml, partPath) {
      let pg = (partPath === "word/document.xml") ? 1 : 0;
      const pgMap = {};
      const all = xml.getElementsByTagName("*");
      for (const el of all) {
        if (partPath === "word/document.xml") {
          if (el.localName === "lastRenderedPageBreak" || (el.localName === "br" && attrW(el, "type") === "page")) pg++;
        }
        if (el.localName === "commentRangeStart") {
          const id = attrW(el, "id");
          if (id !== "") pgMap["c:" + id] = pg;
        }
        if ((el.localName === "ins" || el.localName === "del") && attrW(el, "id") !== "") {
          pgMap[el.localName + ":" + attrW(el, "id")] = pg;
        }
      }
      return { pg: pgMap };
    }

    function extractRevisions(partXml, partPath, ctx) {
      const arr = [];

      function describeBlankRevision(n, type) {
        const kind = (type === "ins") ? "Insertion" : "Deletion";
        const props = new Set();
        const add = (s) => { if (s) props.add(s); };

        const rPrMap = {
          b: "Bold",
          i: "Italic",
          u: "Underline",
          color: "Color",
          highlight: "Highlight",
          strike: "Strikethrough",
          dstrike: "Double-strike",
          caps: "All Caps",
          smallCaps: "Small Caps",
          vertAlign: "Sup/Sub",
          rStyle: "Run Style",
          rFonts: "Font",
          sz: "Font Size",
          szCs: "Font Size (CS)",
          spacing: "Char Spacing",
          position: "Position",
          lang: "Language",
          shd: "Shading",
          emboss: "Emboss",
          imprint: "Imprint",
          outline: "Outline",
          shadow: "Shadow"
        };

        const pPrMap = {
          pStyle: "Paragraph Style",
          jc: "Alignment",
          ind: "Indent",
          spacing: "Paragraph Spacing",
          tabs: "Tabs",
          numPr: "Numbering",
          outlineLvl: "Outline Level",
          keepNext: "Keep Next",
          keepLines: "Keep Lines",
          pageBreakBefore: "Page Break Before",
          widowControl: "Widow Control",
          shd: "Shading",
          sectPr: "Section Props"
        };

        for (const rPr of qAll(n, "rPr")) {
          for (const ch of Array.from(rPr.childNodes)) {
            if (ch.nodeType !== 1) continue;
            add(rPrMap[ch.localName] || ("Run: " + ch.localName));
          }
        }
        for (const pPr of qAll(n, "pPr")) {
          for (const ch of Array.from(pPr.childNodes)) {
            if (ch.nodeType !== 1) continue;
            add(pPrMap[ch.localName] || ("Para: " + ch.localName));
          }
        }

        if (qAll(n, "drawing").length || qAll(n, "pict").length) add("Drawing/Picture");
        if (qAll(n, "hyperlink").length) add("Hyperlink");
        if (qAll(n, "tab").length) add("Tab");
        if (qAll(n, "br").length) {
          const brs = qAll(n, "br");
          const hasPage = brs.some(b => (attrW(b, "type") || "") === "page");
          add(hasPage ? "Page Break" : "Line Break");
        }
        if (qAll(n, "sym").length) add("Symbol");

        if (qAll(n, "fldChar").length || qAll(n, "instrText").length) {
          const instr = qAll(n, "instrText").map(x => x.textContent || "").join("").trim();
          add(instr ? ("Field: " + safeSnippet(instr, 60)) : "Field");
        }

        const rCount = qAll(n, "r").length;
        if (rCount) add("Runs: " + rCount);

        const list = Array.from(props);
        if (list.length === 0) return `[${kind} ‚Äì non-text change]`;
        return `[${kind} ‚Äì non-text] ` + list.slice(0, 8).join(", ") + (list.length > 8 ? "‚Ä¶" : "");
      }
      const push = (nodeList, type) => {
        for (const n of nodeList) {
          const id = attrW(n, "id");
          let txt = "";
          if (type === "ins") for (const t of qAll(n, "t")) txt += t.textContent || "";
          else for (const t of qAll(n, "delText")) txt += t.textContent || "";

          const isSubstantive = !!(txt && String(txt).replace(/\u00a0/g, " ").match(/\S/));

          // Keep formatting-only tracked changes in the DOCX and batch ops (author/date), but hide them from the main table.
          if (!isSubstantive) {
            txt = describeBlankRevision(n, type);
          }

          const pgKey = type + ":" + id;
          arr.push({
            uid: "r" + id,
            id,
            type,
            pg: ctx.pg[pgKey] ?? ((partPath === "word/document.xml") ? 1 : 0),
            part: partPath,
            txt,
            _hidden: !isSubstantive,
            _nonText: !isSubstantive,
            auth: attrW(n, "author") || "",
            date: attrW(n, "date") || "",
          });
        }
      };
      push(qAll(partXml, "ins"), "ins");
      push(qAll(partXml, "del"), "del");
      return arr;
    }

    function extractComments(commentsXml, anchorMap) {
      if (!commentsXml) return [];
      const arr = [];
      const nodes = qAll(commentsXml, "comment");
      for (const n of nodes) {
        const id = attrW(n, "id");
        let txt = "";
        const ps = qAll(n, "p");
        for (let j = 0; j < ps.length; j++) {
          if (j > 0) txt += "\\n";
          txt += ps[j].textContent || "";
        }
        const anchor = anchorMap.get(id) || null;

        arr.push({
          uid: "c" + id,
          id,
          type: "com",
          pg: anchor?.pg ?? 0,
          part: anchor?.part ?? "",
          txt,
          auth: attrW(n, "author") || "",
          date: attrW(n, "date") || "",
        });
      }
      return arr;
    }

    function mergeItems(freshList) {
      for (const fresh of freshList) {
        const existing = items.get(fresh.uid);
        if (existing) {
          existing.pg = fresh.pg;
          existing.part = fresh.part;
          if (fresh.txt != null) existing.txt = fresh.txt;
          if (fresh.auth != null) existing.auth = fresh.auth;
          if (fresh.date != null) existing.date = fresh.date;
        } else {
          items.set(fresh.uid, fresh);
        }
      }
    }

    function rebuildRevisionsAndAnchorsFromLoadedParts() {
      for (const [uid, it] of items.entries()) {
        if (it.type === "ins" || it.type === "del") items.delete(uid);
      }

      const anchorMap = new Map();
      let maxChange = 0;

      for (const meta of partsIndex.values()) {
        if (!meta.loaded || !meta.xmlDoc) continue;
        const ctx = mapContext(meta.xmlDoc, meta.path);

        for (const key of Object.keys(ctx.pg)) {
          if (key.startsWith("c:")) {
            const id = key.slice(2);
            if (!anchorMap.has(id)) anchorMap.set(id, { part: meta.path, pg: ctx.pg[key] ?? 0 });
          }
        }

        // Track max change id across ALL revisions (including non-text) so injected changes don‚Äôt reuse ids
        for (const el of [...qAll(meta.xmlDoc, "ins"), ...qAll(meta.xmlDoc, "del")]) {
          const n = parseInt(attrW(el, "id"), 10);
          if (!isNaN(n)) maxChange = Math.max(maxChange, n);
        }

        const revs = extractRevisions(meta.xmlDoc, meta.path, ctx); // substantive text-only
        mergeItems(revs);
      }

      for (const it of items.values()) {
        if (it.type !== "com") continue;
        const a = anchorMap.get(it.id);
        if (a) { it.part = a.part; it.pg = a.pg; }
      }

      nextChangeId = maxChange + 1;
    }

    function buildInitialActivityFast() {
      items.clear();
      selectedUids.clear();
      pendingGlobalMetaOps = [];

      const anchorMap = new Map();

      if (mainDocXml) {
        const ctx = mapContext(mainDocXml, "word/document.xml");
        for (const key of Object.keys(ctx.pg)) {
          if (key.startsWith("c:")) {
            anchorMap.set(key.slice(2), { part:"word/document.xml", pg: ctx.pg[key] ?? 1 });
          }
        }
        mergeItems(extractRevisions(mainDocXml, "word/document.xml", ctx));

        let max = 0;
        for (const el of [...qAll(mainDocXml, "ins"), ...qAll(mainDocXml, "del")]) {
          const id = parseInt(attrW(el, "id"), 10);
          if (!isNaN(id)) max = Math.max(max, id);
        }
        nextChangeId = max + 1;
      }

      mergeItems(extractComments(commentsXmlDoc, anchorMap));
    }

    function getItemsForMode(mode) {
      const all = Array.from(items.values()).filter(x => !(x && x._hidden));
      if (mode === "comments") return all.filter(x => x.type === "com");
      if (mode === "revisions") return all.filter(x => x.type === "ins" || x.type === "del");
      return all;
    }

    const MAIN_COLS = [
      { k: "_sel", label: "Sel", width: "60px" },
      { k: "pg", label: "Pg", width: "55px" },
      { k: "partLabel", label: "Part", width: "160px" },
      { k: "type", label: "Type", width: "75px" },
      { k: "txt", label: "Text", width: "" },
      { k: "auth", label: "Author", width: "18%" },
      { k: "date", label: "Date", width: "190px" },
    ];

    let mainHeadBuilt = false;

    function getProcessedMainData() {
      const state = tableState.main;
      let src = getItemsForMode(activityMode).map(x => ({...x, partLabel: partLabel(x.part || "")}));

      const filters = state.filters;
      src = src.filter(row => {
        for (const k of Object.keys(filters)) {
          const needle = String(filters[k] || "").toLowerCase();
          if (!needle) continue;
          const hay = String(row[k] || "").toLowerCase();
          if (!hay.includes(needle)) return false;
        }
        return true;
      });

      const col = state.sortCol;
      const dir = state.dir;
      src = stableSort(src, (a,b) => {
        let va = a[col], vb = b[col];
        if (col === "pg") { va = Number(va)||0; vb = Number(vb)||0; }
        else { va = String(va ?? "").toLowerCase(); vb = String(vb ?? "").toLowerCase(); }
        if (va < vb) return -1*dir;
        if (va > vb) return 1*dir;
        return 0;
      });

      return src;
    }

    function syncMainSortIndicators() {
      const trH = dom.tableHead.querySelector("tr");
      if (!trH) return;
      const ths = Array.from(trH.children);
      for (const th of ths) th.classList.remove("sort-asc","sort-desc");

      const state = tableState.main;
      const idx = MAIN_COLS.findIndex(c => c.k === state.sortCol);
      if (idx >= 0 && ths[idx]) ths[idx].classList.add(state.dir === 1 ? "sort-asc" : "sort-desc");
    }

    function buildMainTableHead() {
      if (mainHeadBuilt) return;
      mainHeadBuilt = true;
      dom.tableHead.textContent = "";

      const trH = document.createElement("tr");
      const trF = document.createElement("tr");
      trF.className = "filter-row";

      for (const col of MAIN_COLS) {
        const th = document.createElement("th");
        th.textContent = col.label;
        if (col.width) th.style.width = col.width;

        if (col.k === "_sel") {
          th.style.cursor = "default";
          const master = document.createElement("input");
          master.type = "checkbox";
          master.style.transform = "scale(1.1)";
          master.style.marginLeft = "8px";
          master.addEventListener("change", () => {
            const rows = getProcessedMainData();
            if (master.checked) rows.forEach(r => selectedUids.add(r.uid));
            else rows.forEach(r => selectedUids.delete(r.uid));
            renderMainTableBody();
          });
          th.appendChild(master);
        } else {
          th.addEventListener("click", () => {
            const state = tableState.main;
            if (state.sortCol === col.k) state.dir *= -1;
            else { state.sortCol = col.k; state.dir = 1; }
            syncMainSortIndicators();
            renderMainTableBody();
          });
        }
        trH.appendChild(th);

        const thF = document.createElement("th");
        if (col.k !== "_sel") {
          const inp = document.createElement("input");
          inp.type = "text";
          inp.className = "filter-input";
          inp.value = tableState.main.filters[col.k] || "";
          inp.addEventListener("input", () => {
            if (inp.value && inp.value.trim()) tableState.main.filters[col.k] = inp.value;
            else delete tableState.main.filters[col.k];
            renderMainTableBody();
          });
          thF.appendChild(inp);
        }
        trF.appendChild(thF);
      }

      const thAct = document.createElement("th");
      thAct.textContent = "Act";
      thAct.style.width = "70px";
      trH.appendChild(thAct);
      const thActF = document.createElement("th");
      trF.appendChild(thActF);

      dom.tableHead.appendChild(trH);
      dom.tableHead.appendChild(trF);
      syncMainSortIndicators();
    }

    function renderMainTableBody() {
      buildMainTableHead();
      dom.tableBody.textContent = "";

      const data = getProcessedMainData();
      for (const row of data) {
        const tr = document.createElement("tr");

        const tdSel = document.createElement("td");
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = selectedUids.has(row.uid);
        cb.addEventListener("change", () => {
          if (cb.checked) selectedUids.add(row.uid);
          else selectedUids.delete(row.uid);
        });
        tdSel.appendChild(cb);
        tr.appendChild(tdSel);

        const tdPg = document.createElement("td");
        tdPg.textContent = (row.pg && row.pg !== 0) ? String(row.pg) : "";
        tr.appendChild(tdPg);

        const tdPart = document.createElement("td");
        tdPart.textContent = row.partLabel || "";
        tr.appendChild(tdPart);

        const tdType = document.createElement("td");
        tdType.style.textAlign = "center";
        const b = document.createElement("span");
        b.className = "badge " + (row.type==="com" ? "bg-com" : row.type==="ins" ? "bg-ins" : "bg-del");
        b.textContent = row.type==="com" ? "COM" : row.type==="ins" ? "INS" : "DEL";
        tdType.appendChild(b);
        tr.appendChild(tdType);

        const tdTxt = document.createElement("td");
        tdTxt.className = "editable";
        tdTxt.contentEditable = "true";
        tdTxt.spellcheck = false;
        tdTxt.textContent = row.txt || "";
        tdTxt.addEventListener("blur", () => {
          const it = items.get(row.uid);
          if (it) { it.txt = tdTxt.textContent.trim(); it._dirtyText = true; }
          if (currentTab === "parts") renderSidebarForPart(activePartPath);
        });
        tr.appendChild(tdTxt);

        const tdAuth = document.createElement("td");
        tdAuth.className = "editable";
        tdAuth.contentEditable = "true";
        tdAuth.spellcheck = false;
        tdAuth.textContent = row.auth || "";
        tdAuth.addEventListener("blur", () => {
          const it = items.get(row.uid);
          if (it) { it.auth = tdAuth.textContent.trim(); it._dirtyMeta = true; }
          if (currentTab === "parts") renderSidebarForPart(activePartPath);
        });
        tr.appendChild(tdAuth);

        const tdDate = document.createElement("td");
        const inp = document.createElement("input");
        inp.type = "datetime-local";
        inp.className = "cell-input editish";
        inp.value = toDatetimeLocal(row.date);
        inp.addEventListener("change", () => {
          const it = items.get(row.uid);
          if (it) { it.date = fromDatetimeLocal(inp.value); it._dirtyMeta = true; }
          if (currentTab === "parts") renderSidebarForPart(activePartPath);
        });
        tdDate.appendChild(inp);
        tr.appendChild(tdDate);

        const tdAct = document.createElement("td");
        const btn = document.createElement("button");
        btn.className = "btn btn-secondary";
        btn.type = "button";
        btn.style.padding = "6px 8px";
        btn.style.minWidth = "0";
        btn.style.flex = "0 0 auto";
        btn.textContent = "‚Ü©";
        btn.title = "Jump to item in Parts";
        btn.addEventListener("click", () => stepInto(row.uid));
        tdAct.appendChild(btn);
        tr.appendChild(tdAct);

        dom.tableBody.appendChild(tr);
      }
    }

    function getRenderRoot(xmlDoc, partPath) {
      if (!xmlDoc) return null;
      if (partPath === "word/document.xml") {
        return xmlDoc.getElementsByTagName("w:body")[0] || xmlDoc.getElementsByTagNameNS?.(W_NS,"body")?.[0] || xmlDoc.documentElement;
      }
      const hdr = xmlDoc.getElementsByTagName("w:hdr")[0] || xmlDoc.getElementsByTagNameNS?.(W_NS,"hdr")?.[0];
      if (hdr) return hdr;
      const ftr = xmlDoc.getElementsByTagName("w:ftr")[0] || xmlDoc.getElementsByTagNameNS?.(W_NS,"ftr")?.[0];
      if (ftr) return ftr;
      const foot = xmlDoc.getElementsByTagName("w:footnotes")[0] || xmlDoc.getElementsByTagNameNS?.(W_NS,"footnotes")?.[0];
      if (foot) return foot;
      const endn = xmlDoc.getElementsByTagName("w:endnotes")[0] || xmlDoc.getElementsByTagNameNS?.(W_NS,"endnotes")?.[0];
      if (endn) return endn;
      return xmlDoc.documentElement;
    }

    async function setActivePart(path) {
      if (!partsIndex.has(path)) return;
      activePartPath = path;
      dom.partSelect.value = path;

      await ensurePartLoaded(path);
      renderPart(path);
    }

    function getSidebarDataForPart(partPath) {
      const mode = activityMode;
      let data = getItemsForMode(mode).filter(x => (x.part || "") === partPath);

      const needle = String(dom.partFilter.value || "").toLowerCase().trim();
      if (needle) {
        data = data.filter(x =>
          String(x.txt || "").toLowerCase().includes(needle) ||
          String(x.auth || "").toLowerCase().includes(needle) ||
          String(x.date || "").toLowerCase().includes(needle)
        );
      }

      data = stableSort(data, (a,b) => {
        const pa = Number(a.pg)||0, pb = Number(b.pg)||0;
        if (pa !== pb) return pa - pb;
        const da = String(a.date||""), db = String(b.date||"");
        if (da < db) return -1;
        if (da > db) return 1;
        return String(a.uid).localeCompare(String(b.uid));
      });

      return data;
    }

    function renderSidebarForPart(partPath) {
      dom.docSidebar.textContent = "";
      const data = getSidebarDataForPart(partPath);

      for (const x of data) {
        const card = document.createElement("div");
        card.className = "comment-card";
        card.id = "card-" + x.uid;
        card.style.borderLeft = x.type === "com" ? "4px solid #17a2b8"
                         : x.type === "ins" ? "4px solid #28a745"
                         : "4px solid #dc3545";

        const title = document.createElement("div");
        title.style.fontWeight = "900";
        title.textContent = (x.auth || "(no author)") + (x.date ? (" ‚Ä¢ " + safeSnippet(x.date, 30)) : "");
        card.appendChild(title);

        const body = document.createElement("div");
        body.style.opacity = "0.95";
        body.style.whiteSpace = "pre-wrap";
        body.textContent = safeSnippet(x.txt, 140);
        card.appendChild(body);

        card.addEventListener("click", () => focusUidInCurrentPart(x.uid));
        dom.docSidebar.appendChild(card);
      }
    }

    function renderDocView(xmlDoc, partPath) {
      dom.docContent.textContent = "";
      const root = getRenderRoot(xmlDoc, partPath);
      if (!root) return;

      const activeComments = [];
      const firstRendered = new Set();

      function removeActiveComment(id){
        for (let i=activeComments.length-1;i>=0;i--){
          if (activeComments[i]===id){ activeComments.splice(i,1); return; }
        }
      }

      function wrapAndAppend(parent, el){
        let container = parent;
        for (const cid of activeComments) {
          const uid = "c" + cid;
          const s = document.createElement("span");
          s.className = "doc-com";
          s.dataset.uid = uid;
          if (!firstRendered.has(uid)) { s.id = "hl-" + uid; firstRendered.add(uid); }
          s.addEventListener("click",(ev)=>{ ev.stopPropagation(); stepInto(uid); });
          container.appendChild(s);
          container = s;
        }
        container.appendChild(el);
      }

      function appendText(parent, text){
        if (!text) return;
        if (activeComments.length===0) parent.appendChild(document.createTextNode(text));
        else wrapAndAppend(parent, document.createTextNode(text));
      }
      function appendBr(parent){
        const br = document.createElement("br");
        if (activeComments.length===0) parent.appendChild(br);
        else wrapAndAppend(parent, br);
      }

      function walk(parent, node){
        if (!node) return;
        const ln = node.localName;

        if (ln === "commentRangeStart") {
          const id = attrW(node,"id");
          if (id !== "") {
            activeComments.push(id);
            const uid = "c" + id;
            if (!firstRendered.has(uid)) {
              const marker = document.createElement("span");
              marker.className = "doc-com";
              marker.dataset.uid = uid;
              marker.id = "hl-" + uid;
              marker.style.padding="0";
              marker.style.border="0";
              marker.style.background="transparent";
              marker.addEventListener("click",(ev)=>{ ev.stopPropagation(); stepInto(uid); });
              wrapAndAppend(parent, marker);
              firstRendered.add(uid);
            }
          }
          return;
        }
        if (ln === "commentRangeEnd") { const id = attrW(node,"id"); if (id !== "") removeActiveComment(id); return; }
        if (ln === "commentReference") return;

        
        if (ln === "tbl") {
          const table = document.createElement("table");
          table.className = "doc-table";
          parent.appendChild(table);

          node.childNodes.forEach(trNode => {
            if (!trNode || !trNode.localName) return;
            if (trNode.localName !== "tr") return;

            const tr = document.createElement("tr");
            table.appendChild(tr);

            trNode.childNodes.forEach(tcNode => {
              if (!tcNode || !tcNode.localName) return;
              if (tcNode.localName !== "tc") return;

              const td = document.createElement("td");
              tr.appendChild(td);

              tcNode.childNodes.forEach(ch => {
                if (!ch) return;
                if (ch.localName === "tcPr") return;
                walk(td, ch);
              });
            });
          });
          return;
        }

        if (ln === "p") {
          const p = document.createElement("p");
          parent.appendChild(p);
          node.childNodes.forEach(ch => walk(p,ch));
          return;
        }
        if (ln === "t" || ln === "delText") { appendText(parent, node.textContent || ""); return; }
        if (ln === "br") { appendBr(parent); return; }

        if (ln === "ins" || ln === "del") {
          const id = attrW(node,"id");
          const uid = "r" + id;
          const span = document.createElement("span");
          span.className = (ln === "ins") ? "doc-ins" : "doc-del";
          span.id = "hl-" + uid;
          span.dataset.uid = uid;
          span.addEventListener("click",(ev)=>{ ev.stopPropagation(); stepInto(uid); });
          wrapAndAppend(parent, span);
          node.childNodes.forEach(ch => walk(span,ch));
          return;
        }

        if (node.childNodes && node.childNodes.length) node.childNodes.forEach(ch => walk(parent,ch));
      }

      walk(dom.docContent, root);
    }

    function renderPart(path) {
      const meta = partsIndex.get(path);
      if (!meta || !meta.loaded || !meta.xmlDoc) return;
      renderDocView(meta.xmlDoc, path);
      renderSidebarForPart(path);
    }

    function focusUidInCurrentPart(uid) {
      setTimeout(() => {
        const el = document.getElementById("hl-" + uid);
        const card = document.getElementById("card-" + uid);

        if (el) {
          el.scrollIntoView({ behavior:"smooth", block:"center" });
          el.classList.add("flash-target");
          setTimeout(()=>el.classList.remove("flash-target"), 2000);
        }
        if (card) {
          card.scrollIntoView({ behavior:"smooth", block:"nearest" });
          card.classList.add("active-card");
          setTimeout(()=>card.classList.remove("active-card"), 2000);
        }
      }, 80);
    }

    async function stepInto(uid) {
      const it = items.get(uid);
      if (it && it.part && partsIndex.has(it.part)) {
        switchTab("parts");
        await setActivePart(it.part);
        focusUidInCurrentPart(uid);
        return;
      }
      switchTab("parts");
      await setActivePart("word/document.xml");
      focusUidInCurrentPart(uid);
    }

    const REL_COLS = [
      { k:"risk", label:"Risk", width:"70px" },
      { k:"sourceLabel", label:"From", width:"180px" },
      { k:"typeLabel", label:"Type", width:"200px" },
      { k:"targetShown", label:"Target", width:"" },
      { k:"mode", label:"Mode", width:"90px" },
      { k:"existsLabel", label:"Exists", width:"90px" },
      { k:"refs", label:"Refs", width:"70px" },
    ];
    let relHeadBuilt = false;

    function relTypeLabel(typeUri) {
      const m = {
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink":"Hyperlink",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image":"Image",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles":"Styles",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering":"Numbering",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme":"Theme",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header":"Header",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer":"Footer",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments":"Comments",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes":"Footnotes",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/endnotes":"Endnotes",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/attachedTemplate":"Attached Template",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject":"OLE Object",
        "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties":"Core Properties",
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml":"Custom XML",
        "http://schemas.microsoft.com/office/2011/relationships/webextension":"Web Extension",
        "http://schemas.microsoft.com/office/2006/relationships/ui/extensibility":"Office Add-in/Extensibility",
      };
      return m[typeUri] || (typeUri ? typeUri.split("/").pop() : "(unknown)");
    }

    function relRisk(typeUri, targetMode, target) {
      const isExt = (String(targetMode||"").toLowerCase()==="external") ||
                    /^https?:\/\//i.test(target||"") ||
                    /^file:\/\//i.test(target||"");
      if (isExt) return { label:"HIGH", rank:1, cls:"bg-hi" };
      const low = { label:"LOW", rank:3, cls:"bg-lo" };
      if (!typeUri) return low;
      if (typeUri.includes("attachedTemplate") || typeUri.includes("webextension") || typeUri.includes("oleObject")) {
        return { label:"MED", rank:2, cls:"bg-med" };
      }
      return low;
    }

    function getSourcePartFromRelsPath(relsPath) {
      if (relsPath === "_rels/.rels") return "[root]";
      if (!relsPath.includes("/_rels/")) return "[unknown]";
      return relsPath.replace("/_rels/","/").replace(/\.rels$/i,"");
    }

    function countOccurrences(hay, needle) {
      if (!hay || !needle) return 0;
      let count = 0, idx = 0;
      while (true) {
        idx = hay.indexOf(needle, idx);
        if (idx === -1) break;
        count++;
        idx += needle.length;
      }
      return count;
    }

    async function buildRelationshipsOnDemand() {
      if (!zipObj) return;
      relationshipsData = [];
      relationshipsBuilt = true;

      setStatus("Building relationship index‚Ä¶", true);

      const relPaths = [];
      zipObj.forEach((path) => { if (path.toLowerCase().endsWith(".rels")) relPaths.push(path); });

      const srcXmlCache = new Map();

      let processed = 0;
      for (const relsPath of relPaths) {
        const relStr = await zipObj.file(relsPath).async("string");
        const relDoc = new DOMParser().parseFromString(relStr, "text/xml");
        if (isParserError(relDoc)) continue;

        const relNodes = relDoc.getElementsByTagNameNS ? Array.from(relDoc.getElementsByTagNameNS("*","Relationship"))
                                                      : Array.from(relDoc.getElementsByTagName("Relationship"));

        const sourcePart = getSourcePartFromRelsPath(relsPath);
        const baseDir = (sourcePart === "[root]" || sourcePart === "[unknown]") ? "" : (sourcePart.substring(0, sourcePart.lastIndexOf("/") + 1));

        let srcXml = "";
        if ((sourcePart.startsWith("word/") || sourcePart.startsWith("docProps/")) && zipObj.file(sourcePart)) {
          if (!srcXmlCache.has(sourcePart)) srcXmlCache.set(sourcePart, await zipObj.file(sourcePart).async("string"));
          srcXml = srcXmlCache.get(sourcePart) || "";
        }

        for (const r of relNodes) {
          const rId = r.getAttribute("Id") || "";
          const typeUri = r.getAttribute("Type") || "";
          const target = r.getAttribute("Target") || "";
          const targetMode = r.getAttribute("TargetMode") || "";

          const resolved = (String(targetMode).toLowerCase()==="external") ? target : normalizePath(baseDir, target);
          const exists = (String(targetMode).toLowerCase()==="external") ? false : !!zipObj.file(resolved);

          const risk = relRisk(typeUri, targetMode, target);
          const refs = srcXml ? countOccurrences(srcXml, rId) : 0;

          relationshipsData.push({
            relsPath,
            sourcePart,
            sourceLabel: partLabel(sourcePart),
            rId,
            typeUri,
            typeLabel: relTypeLabel(typeUri),
            target,
            mode: targetMode || "Internal",
            resolvedTarget: resolved,
            targetShown: (String(targetMode).toLowerCase()==="external") ? target : resolved,
            exists,
            existsLabel: (String(targetMode).toLowerCase()==="external") ? "‚Äî" : (exists ? "Yes" : "No"),
            risk: risk.label,
            riskRank: risk.rank,
            riskCls: risk.cls,
            refs,
          });

          processed++;
          if (processed % 600 === 0) {
            setStatus("Building relationship index‚Ä¶ (" + processed + ")", true);
            await yieldToUI();
          }
        }
      }

      setStatus("Relationships ready.", true);
      renderRelTable();
    }

    function getProcessedRelData() {
      const state = tableState.rel;
      let src = relationshipsData.slice();

      const filters = state.filters;
      src = src.filter(row => {
        for (const k of Object.keys(filters)) {
          const needle = String(filters[k] || "").toLowerCase();
          if (!needle) continue;
          const hay = String(row[k] || "").toLowerCase();
          if (!hay.includes(needle)) return false;
        }
        return true;
      });

      const col = state.sortCol;
      const dir = state.dir;
      src = stableSort(src, (a,b) => {
        let va = a[col], vb = b[col];
        if (col === "riskRank" || col === "refs") { va = Number(va)||0; vb = Number(vb)||0; }
        else { va = String(va ?? "").toLowerCase(); vb = String(vb ?? "").toLowerCase(); }
        if (va < vb) return -1*dir;
        if (va > vb) return 1*dir;
        return 0;
      });

      return src;
    }

    function syncRelSortIndicators() {
      const trH = dom.relHead.querySelector("tr");
      if (!trH) return;
      const ths = Array.from(trH.children);
      for (const th of ths) th.classList.remove("sort-asc","sort-desc");

      const keys = REL_COLS.map(c => (c.k==="risk" ? "riskRank" : c.k)).concat(["_act"]);
      const state = tableState.rel;
      const idx = keys.indexOf(state.sortCol);
      if (idx >= 0 && ths[idx]) ths[idx].classList.add(state.dir===1 ? "sort-asc" : "sort-desc");
    }

    function buildRelHead() {
      if (relHeadBuilt) return;
      relHeadBuilt = true;

      dom.relHead.textContent = "";
      const trH = document.createElement("tr");
      const trF = document.createElement("tr");
      trF.className = "filter-row";

      for (const col of REL_COLS) {
        const th = document.createElement("th");
        th.textContent = col.label;
        if (col.width) th.style.width = col.width;
        th.addEventListener("click", () => {
          const key = (col.k==="risk") ? "riskRank" : col.k;
          const state = tableState.rel;
          if (state.sortCol === key) state.dir *= -1;
          else { state.sortCol = key; state.dir = 1; }
          syncRelSortIndicators();
          renderRelBody();
        });
        trH.appendChild(th);

        const thF = document.createElement("th");
        const inp = document.createElement("input");
        inp.type = "text";
        inp.className = "filter-input";
        inp.value = tableState.rel.filters[col.k] || "";
        inp.addEventListener("input", () => {
          if (inp.value && inp.value.trim()) tableState.rel.filters[col.k] = inp.value;
          else delete tableState.rel.filters[col.k];
          renderRelBody();
        });
        thF.appendChild(inp);
        trF.appendChild(thF);
      }

      const thAct = document.createElement("th");
      thAct.textContent = "Act";
      thAct.style.width = "140px";
      trH.appendChild(thAct);

      const thActF = document.createElement("th");
      trF.appendChild(thActF);

      dom.relHead.appendChild(trH);
      dom.relHead.appendChild(trF);
      syncRelSortIndicators();
    }

    async function dlFile(path) {
      if (!zipObj || !zipObj.file(path)) return;
      const blob = await zipObj.file(path).async("blob");
      saveAs(blob, path.split("/").pop() || "file.bin");
    }

    function renderRelBody() {
      buildRelHead();
      dom.relBody.textContent = "";
      const data = getProcessedRelData();

      for (const r of data) {
        const tr = document.createElement("tr");

        const tdRisk = document.createElement("td");
        const badge = document.createElement("span");
        badge.className = "badge " + r.riskCls;
        badge.textContent = r.risk;
        tdRisk.appendChild(badge);
        tr.appendChild(tdRisk);

        const tdFrom = document.createElement("td");
        tdFrom.textContent = r.sourceLabel || r.sourcePart;
        tr.appendChild(tdFrom);

        const tdType = document.createElement("td");
        tdType.textContent = r.typeLabel || "";
        tr.appendChild(tdType);

        const tdTarget = document.createElement("td");
        tdTarget.textContent = r.targetShown || r.target || "";
        tr.appendChild(tdTarget);

        const tdMode = document.createElement("td");
        tdMode.textContent = r.mode;
        tr.appendChild(tdMode);

        const tdEx = document.createElement("td");
        tdEx.textContent = r.existsLabel;
        tdEx.style.fontWeight = (r.existsLabel==="No") ? "900" : "400";
        tdEx.style.color = (r.existsLabel==="No") ? "crimson" : "#333";
        tr.appendChild(tdEx);

        const tdRefs = document.createElement("td");
        tdRefs.textContent = String(r.refs || 0);
        tr.appendChild(tdRefs);

        const tdAct = document.createElement("td");
        tdAct.style.display="flex";
        tdAct.style.gap="6px";

        const btnOpen = document.createElement("button");
        btnOpen.className="btn btn-secondary";
        btnOpen.type="button";
        btnOpen.style.padding="6px 8px";
        btnOpen.style.minWidth="0";
        btnOpen.style.flex="0 0 auto";
        btnOpen.textContent="Open";
        btnOpen.addEventListener("click", async () => {
          if (partsIndex.has(r.sourcePart)) {
            switchTab("parts");
            await setActivePart(r.sourcePart);
          } else {
            alert("Source part not in Word parts list.");
          }
        });
        tdAct.appendChild(btnOpen);

        const btnDl = document.createElement("button");
        btnDl.className="btn btn-secondary";
        btnDl.type="button";
        btnDl.style.padding="6px 8px";
        btnDl.style.minWidth="0";
        btnDl.style.flex="0 0 auto";
        btnDl.textContent="DL";
        btnDl.disabled = (String(r.mode).toLowerCase()==="external") || !r.exists;
        btnDl.addEventListener("click", () => dlFile(r.resolvedTarget));
        tdAct.appendChild(btnDl);

        tr.appendChild(tdAct);
        dom.relBody.appendChild(tr);
      }
    }

    function renderRelTable() {
      renderRelBody();
    }

    const FORENSICS_COLS = [
      { k:"path", label:"File" },
      { k:"type", label:"Type" },
      { k:"size", label:"Size" },
      { k:"risks", label:"Risks" },
    ];
    let forHeadBuilt = false;

    function getProcessedForensicsData() {
      const state = tableState.forensics;
      let src = forensicsData.slice();

      const filters = state.filters;
      src = src.filter(row => {
        for (const k of Object.keys(filters)) {
          const needle = String(filters[k] || "").toLowerCase();
          if (!needle) continue;
          const hay = String(row[k] || "").toLowerCase();
          if (!hay.includes(needle)) return false;
        }
        return true;
      });

      const col = state.sortCol;
      const dir = state.dir;
      src = stableSort(src, (a,b) => {
        let va = a[col], vb = b[col];
        if (col === "size") { va = Number(va)||0; vb = Number(vb)||0; }
        else { va = String(va ?? "").toLowerCase(); vb = String(vb ?? "").toLowerCase(); }
        if (va < vb) return -1*dir;
        if (va > vb) return 1*dir;
        return 0;
      });

      return src;
    }

    function syncForSortIndicators() {
      const trH = dom.forHead.querySelector("tr");
      if (!trH) return;
      const ths = Array.from(trH.children);
      for (const th of ths) th.classList.remove("sort-asc","sort-desc");

      const state = tableState.forensics;
      const idx = FORENSICS_COLS.findIndex(c => c.k === state.sortCol);
      if (idx >= 0 && ths[idx]) ths[idx].classList.add(state.dir===1 ? "sort-asc" : "sort-desc");
    }

    function buildForensicsHead() {
      if (forHeadBuilt) return;
      forHeadBuilt = true;

      dom.forHead.textContent = "";
      const trH = document.createElement("tr");
      const trF = document.createElement("tr");
      trF.className="filter-row";

      for (const col of FORENSICS_COLS) {
        const th = document.createElement("th");
        th.textContent = col.label;
        th.addEventListener("click", () => {
          const state = tableState.forensics;
          if (state.sortCol === col.k) state.dir *= -1;
          else { state.sortCol = col.k; state.dir = 1; }
          syncForSortIndicators();
          renderForensicsBody();
        });
        trH.appendChild(th);

        const thF = document.createElement("th");
        const inp = document.createElement("input");
        inp.type="text";
        inp.className="filter-input";
        inp.value = tableState.forensics.filters[col.k] || "";
        inp.addEventListener("input", () => {
          if (inp.value && inp.value.trim()) tableState.forensics.filters[col.k] = inp.value;
          else delete tableState.forensics.filters[col.k];
          renderForensicsBody();
        });
        thF.appendChild(inp);
        trF.appendChild(thF);
      }

      const thDl = document.createElement("th");
      thDl.textContent="DL";
      thDl.style.width="70px";
      trH.appendChild(thDl);
      const thDlF = document.createElement("th");
      trF.appendChild(thDlF);

      dom.forHead.appendChild(trH);
      dom.forHead.appendChild(trF);
      syncForSortIndicators();
    }

    function renderForensicsBody() {
      buildForensicsHead();
      dom.forBody.textContent = "";

      const data = getProcessedForensicsData();
      for (const row of data) {
        const tr = document.createElement("tr");

        const tdPath = document.createElement("td"); tdPath.textContent = row.path || ""; tr.appendChild(tdPath);
        const tdType = document.createElement("td"); tdType.textContent = row.type || ""; tr.appendChild(tdType);
        const tdSize = document.createElement("td"); tdSize.textContent = (row.size!=null) ? ((row.size/1024).toFixed(1) + " KB") : ""; tr.appendChild(tdSize);

        const tdRisk = document.createElement("td");
        if (row.risks && row.risks !== "Clean") {
          tdRisk.style.color="crimson";
          tdRisk.style.fontWeight="900";
          tdRisk.textContent = "‚ö† " + row.risks;
        } else {
          tdRisk.style.color="green";
          tdRisk.textContent = "‚úì Clean";
        }
        tr.appendChild(tdRisk);

        const tdDl = document.createElement("td");
        const btn = document.createElement("button");
        btn.className="btn btn-secondary";
        btn.type="button";
        btn.style.padding="6px 8px";
        btn.style.minWidth="0";
        btn.style.flex="0 0 auto";
        btn.textContent="‚¨á";
        btn.addEventListener("click", () => dlFile(row.path));
        tdDl.appendChild(btn);
        tr.appendChild(tdDl);

        dom.forBody.appendChild(tr);
      }
    }

    async function scanForensics() {
      if (!zipObj) return;
      setStatus("Scanning binaries‚Ä¶", true);
      forensicsData = [];

      const tasks = [];
      zipObj.forEach((path, file) => {
        const ext = (path.split(".").pop() || "").toLowerCase();
        if (!["xml","rels"].includes(ext) && path !== "[Content_Types].xml") {
          tasks.push(file.async("uint8array").then(data => {
            let head = "";
            try { head = new TextDecoder().decode(data.slice(0, 200)); } catch { head = ""; }
            const risks = [];
            if (head.includes("Exif")) risks.push("EXIF");
            if (head.includes("Adobe")) risks.push("XMP/Adobe");
            if (head.includes("Photoshop")) risks.push("Photoshop");
            forensicsData.push({
              path,
              type: ext ? ext.toUpperCase() : "(none)",
              size: data.length,
              risks: risks.join(", ") || "Clean",
            });
          }));
        }
      });

      await Promise.all(tasks);
      renderForensicsBody();
      setStatus("Scan complete.", true);
    }


    const RX_COLS = [
      { k:"pg", label:"Pg", width:"60px" },
      { k:"part", label:"Part", width:"180px" },
      { k:"node", label:"Node", width:"90px" },
      { k:"before", label:"Original", width:"" },
      { k:"after", label:"Revised", width:"" },
    ];

    function getProcessedRegexData() {
      const state = tableState.regex;
      let src = regexChanges.slice();

      const filters = state.filters;
      src = src.filter(row => {
        for (const k of Object.keys(filters)) {
          const needle = String(filters[k] || "").toLowerCase();
          if (!needle) continue;
          const hay = String(row[k] || "").toLowerCase();
          if (!hay.includes(needle)) return false;
        }
        return true;
      });

      const col = state.sortCol;
      const dir = state.dir;
      src = stableSort(src, (a,b) => {
        let va = a[col], vb = b[col];
        if (col === "pg") { va = Number(va)||0; vb = Number(vb)||0; }
        else { va = String(va ?? "").toLowerCase(); vb = String(vb ?? "").toLowerCase(); }
        if (va < vb) return -1*dir;
        if (va > vb) return 1*dir;
        return 0;
      });

      return src;
    }

    function syncRxSortIndicators() {
      const trH = dom.rxHead.querySelector("tr");
      if (!trH) return;
      const ths = Array.from(trH.children);
      for (const th of ths) th.classList.remove("sort-asc","sort-desc");

      const state = tableState.regex;
      const idx = RX_COLS.findIndex(c => c.k === state.sortCol);
      if (idx >= 0 && ths[idx]) ths[idx].classList.add(state.dir===1 ? "sort-asc" : "sort-desc");
    }

    function buildRegexHead() {
      if (regexHeadBuilt) return;
      regexHeadBuilt = true;
      dom.rxHead.textContent = "";

      const trH = document.createElement("tr");
      const trF = document.createElement("tr");
      trF.className = "filter-row";

      for (const col of RX_COLS) {
        const th = document.createElement("th");
        th.textContent = col.label;
        if (col.width) th.style.width = col.width;
        th.addEventListener("click", () => {
          const state = tableState.regex;
          if (state.sortCol === col.k) state.dir *= -1;
          else { state.sortCol = col.k; state.dir = 1; }
          syncRxSortIndicators();
          renderRegexBody();
        });
        trH.appendChild(th);

        const thF = document.createElement("th");
        const inp = document.createElement("input");
        inp.type = "text";
        inp.className = "filter-input";
        inp.value = tableState.regex.filters[col.k] || "";
        inp.addEventListener("input", () => {
          if (inp.value && inp.value.trim()) tableState.regex.filters[col.k] = inp.value;
          else delete tableState.regex.filters[col.k];
          renderRegexBody();
        });
        thF.appendChild(inp);
        trF.appendChild(thF);
      }

      dom.rxHead.appendChild(trH);
      dom.rxHead.appendChild(trF);
      syncRxSortIndicators();
    }

    function renderRegexBody() {
      buildRegexHead();
      dom.rxBody.textContent = "";

      const data = getProcessedRegexData();
      for (const r of data) {
        const tr = document.createElement("tr");

        const tdPg = document.createElement("td");
        tdPg.textContent = (r.pg && r.pg !== 0) ? String(r.pg) : "";
        tr.appendChild(tdPg);

        const tdPart = document.createElement("td");
        tdPart.textContent = r.part || "";
        tr.appendChild(tdPart);

        const tdNode = document.createElement("td");
        tdNode.textContent = r.node || "";
        tr.appendChild(tdNode);

        const tdBefore = document.createElement("td");
        tdBefore.style.whiteSpace = "pre-wrap";
        tdBefore.textContent = r.before || "";
        tr.appendChild(tdBefore);

        const tdAfter = document.createElement("td");
        tdAfter.style.whiteSpace = "pre-wrap";
        tdAfter.textContent = r.after || "";
        tr.appendChild(tdAfter);

        dom.rxBody.appendChild(tr);
      }
    }

    async function runRegexReplace() {
      if (!zipObj) { alert("Load a DOCX first."); return; }

      const pattern = String(dom.rxPattern.value || "");
      const replacement = String(dom.rxReplace.value || "");

      if (!pattern.trim()) { alert("Enter a regex pattern."); return; }

      let flags = "g";
      if (dom.rxI.checked) flags += "i";
      if (dom.rxM.checked) flags += "m";
      if (dom.rxS.checked) flags += "s";

      let rx;
      try { rx = new RegExp(pattern, flags); }
      catch (e) { alert("Invalid regex: " + (e.message || e)); return; }

      const scope = dom.rxScope.value;

      let targets = [];
      if (scope === "active") targets = [activePartPath];
      else if (scope === "loaded") targets = Array.from(partsIndex.values()).filter(m => m.loaded).map(m => m.path);
      else if (scope === "all") targets = Array.from(partsIndex.keys());
      else targets = ["word/document.xml"]; // main

      targets = Array.from(new Set(targets));
      const idx = targets.indexOf("word/document.xml");
      if (idx > 0) { targets.splice(idx,1); targets.unshift("word/document.xml"); }

      regexChanges = [];
      regexHeadBuilt = false;
      dom.rxHead.textContent = "";
      dom.rxBody.textContent = "";

      setStatus("Running regex replace‚Ä¶", true);

      for (let ti=0; ti<targets.length; ti++) {
        const p = targets[ti];
        if (!partsIndex.has(p)) continue;

        await ensurePartLoaded(p);
        const meta = partsIndex.get(p);
        if (!meta || !meta.xmlDoc) continue;

        const xml = meta.xmlDoc;
        let page = (p === "word/document.xml") ? 1 : 0;

        const stack = [xml.documentElement];
        let steps = 0;

        while (stack.length) {
          const node = stack.pop();
          if (!node || node.nodeType !== 1) continue;

          const ln = node.localName;

          if (p === "word/document.xml") {
            if (ln === "lastRenderedPageBreak" || (ln === "br" && attrW(node, "type") === "page")) page++;
          }

          if (ln === "t" || ln === "delText") {
            const old = node.textContent || "";
            if (old) {
              const neu = old.replace(rx, replacement);
              if (neu !== old) {
                node.textContent = neu;
                setAttrXmlSpacePreserve(node, neu);
                regexChanges.push({
                  pg: page,
                  part: partLabel(p),
                  node: (ln === "delText") ? "delText" : "t",
                  before: old,
                  after: neu
                });
              }
            }
          }

          if (node.childNodes && node.childNodes.length) {
            for (let i=node.childNodes.length-1; i>=0; i--) {
              const ch = node.childNodes[i];
              if (ch && ch.nodeType === 1) stack.push(ch);
            }
          }

          steps++;
          if (steps % 4000 === 0) await yieldToUI();
        }

        meta.loaded = true;
        meta.xmlDoc = xml;
        partsIndex.set(p, meta);
        if (p === "word/document.xml") mainDocXml = xml;
      }

      rebuildRevisionsAndAnchorsFromLoadedParts();

      if (currentTab === "parts") renderPart(activePartPath);

      renderRegexBody();
      setStatus("Regex replace complete. " + regexChanges.length + " change(s).", true);
      refreshExportButtons();
    }

    function clearRegexLog() {
      regexChanges = [];
      regexHeadBuilt = false;
      dom.rxHead.textContent = "";
      dom.rxBody.textContent = "";
      renderRegexBody();
      refreshExportButtons();
    }


    function getExportSpecForCurrentTab() {
      const nowTag = new Date().toISOString().replace(/[:.]/g,"-").slice(0,19);
      const base = (originalFileName || "document.docx").replace(/\.docx$/i,"");

      if (currentTab === "comments" || currentTab === "revisions" || currentTab === "all") {
        const data = getProcessedMainData();
        const headers = ["Pg","Part","Type","Text","Author","Date"];
        const rows = data.map(r => [
          r.pg || "",
          r.partLabel || "",
          (r.type==="com" ? "COM" : r.type==="ins" ? "INS" : "DEL"),
          r.txt || "",
          r.auth || "",
          r.date || ""
        ]);
        const name = (currentTab === "comments") ? "Comments"
                   : (currentTab === "revisions") ? "Changes"
                   : "All-Activity";
        return { filename: `${base}_${name}_${nowTag}.xlsx`, sheet: name, headers, rows };
      }

      if (currentTab === "parts") {
        const partPath = activePartPath;
        const data = getSidebarDataForPart(partPath);
        const headers = ["Pg","Part","Type","Text","Author","Date","UID"];
        const rows = data.map(r => [
          r.pg || "",
          partLabel(r.part || partPath),
          (r.type==="com" ? "COM" : r.type==="ins" ? "INS" : "DEL"),
          r.txt || "",
          r.auth || "",
          r.date || "",
          r.uid || ""
        ]);
        const name = `Part-${partLabel(partPath).replace(/\s+/g,"-")}`;
        return { filename: `${base}_${name}_${nowTag}.xlsx`, sheet: "Part", headers, rows };
      }

      if (currentTab === "relationships") {
        const data = getProcessedRelData();
        const headers = ["Risk","From","Type","Target","Mode","Exists","Refs","rId","relsPath","typeUri"];
        const rows = data.map(r => [
          r.risk || "",
          r.sourceLabel || r.sourcePart || "",
          r.typeLabel || "",
          r.targetShown || "",
          r.mode || "",
          r.existsLabel || "",
          r.refs || 0,
          r.rId || "",
          r.relsPath || "",
          r.typeUri || ""
        ]);
        return { filename: `${base}_Relationships_${nowTag}.xlsx`, sheet:"Relationships", headers, rows };
      }

      if (currentTab === "forensics") {
        const data = getProcessedForensicsData();
        const headers = ["File","Type","SizeBytes","Risks"];
        const rows = data.map(r => [ r.path || "", r.type || "", r.size || 0, r.risks || "" ]);
        return { filename: `${base}_Forensics_${nowTag}.xlsx`, sheet:"Forensics", headers, rows };
      }

      return null;
    }

    function getCopyTextForCurrentTab() {
      const spec = getExportSpecForCurrentTab();
      if (!spec) return null;
      const esc = (v) => String(v ?? "").replace(/\r?\n/g,"\\n");
      const lines = [];
      lines.push(spec.headers.map(esc).join("\t"));
      for (const row of spec.rows) lines.push(row.map(esc).join("\t"));
      return lines.join("\n");
    }

    async function copyCurrentTab() {
      const txt = getCopyTextForCurrentTab();
      if (!txt) { alert("Nothing to copy on this tab."); return; }
      try {
        await navigator.clipboard.writeText(txt);
        alert("Copied (TSV).");
      } catch {
        const ta = document.createElement("textarea");
        ta.value = txt;
        ta.style.position="fixed";
        ta.style.left="-2000px";
        ta.style.top="0";
        document.body.appendChild(ta);
        ta.select();
        try {
          const ok = document.execCommand("copy");
          alert(ok ? "Copied (legacy)." : "Copy failed.");
        } finally {
          document.body.removeChild(ta);
        }
      }
    }

    function exportCurrentTabXlsx() {
      const spec = getExportSpecForCurrentTab();
      if (!spec) { alert("Nothing to export on this tab."); return; }

      const aoa = [spec.headers, ...spec.rows];
      const ws = XLSX.utils.aoa_to_sheet(aoa);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, spec.sheet || "Sheet1");
      const out = XLSX.write(wb, { bookType:"xlsx", type:"array" });
      const blob = new Blob([out], { type:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
      saveAs(blob, spec.filename || "export.xlsx");
    }

    function refreshExportButtons() {
      const enabled = (currentTab === "comments" || currentTab === "revisions" || currentTab === "all" ||
                       currentTab === "parts" || currentTab === "relationships" || currentTab === "forensics" || currentTab === "regex");
      dom.btnCopy.disabled = !enabled;
      dom.btnExport.disabled = !enabled;
    }

    function populateMeta() {
      if (coreXmlDoc) {
        const creator = qAll(coreXmlDoc,"creator")[0] || coreXmlDoc.getElementsByTagName("dc:creator")[0];
        const lastMod = qAll(coreXmlDoc,"lastModifiedBy")[0] || coreXmlDoc.getElementsByTagName("cp:lastModifiedBy")[0];
        if (creator) dom.metaCreator.value = creator.textContent || "";
        if (lastMod) dom.metaLastMod.value = lastMod.textContent || "";
      }
      if (appXmlDoc) {
        const totalTime = qAll(appXmlDoc,"TotalTime")[0] || appXmlDoc.getElementsByTagName("TotalTime")[0];
        const revision = qAll(appXmlDoc,"Revision")[0] || appXmlDoc.getElementsByTagName("Revision")[0];
        if (totalTime) dom.metaTime.value = totalTime.textContent || "";
        if (revision) dom.metaRevision.value = revision.textContent || "";
      }
    }

    function writeMetaBackToZip() {
      if (!metaDirty) return;
      if (!zipObj) return;
      const ser = new XMLSerializer();

      if (coreXmlDoc) {
        const creator = qAll(coreXmlDoc,"creator")[0] || coreXmlDoc.getElementsByTagName("dc:creator")[0];
        const lastMod = qAll(coreXmlDoc,"lastModifiedBy")[0] || coreXmlDoc.getElementsByTagName("cp:lastModifiedBy")[0];
        if (creator) creator.textContent = dom.metaCreator.value || "";
        if (lastMod) lastMod.textContent = dom.metaLastMod.value || "";
        zipObj.file("docProps/core.xml", ser.serializeToString(coreXmlDoc));
      }
      if (appXmlDoc) {
        const totalTime = qAll(appXmlDoc,"TotalTime")[0] || appXmlDoc.getElementsByTagName("TotalTime")[0];
        const revision = qAll(appXmlDoc,"Revision")[0] || appXmlDoc.getElementsByTagName("Revision")[0];
        if (totalTime) totalTime.textContent = String(dom.metaTime.value || "0");
        if (revision) revision.textContent = String(dom.metaRevision.value || "0");
        zipObj.file("docProps/app.xml", ser.serializeToString(appXmlDoc));
      }
    }

    function wipeMetadata() {
      if (!confirm("Wipe metadata (core/app + rsid across LOADED Word parts)?")) return;

      if (coreXmlDoc) {
        const creator = qAll(coreXmlDoc,"creator")[0] || coreXmlDoc.getElementsByTagName("dc:creator")[0];
        const lastMod = qAll(coreXmlDoc,"lastModifiedBy")[0] || coreXmlDoc.getElementsByTagName("cp:lastModifiedBy")[0];
        if (creator) creator.textContent = "Author";
        if (lastMod) lastMod.textContent = "Author";
        dom.metaCreator.value = "Author";
        dom.metaLastMod.value = "Author";
      }
      if (appXmlDoc) {
        const totalTime = qAll(appXmlDoc,"TotalTime")[0] || appXmlDoc.getElementsByTagName("TotalTime")[0];
        if (totalTime) totalTime.textContent = "0";
        dom.metaTime.value = "0";
      }

      for (const meta of partsIndex.values()) {
        if (!meta.loaded || !meta.xmlDoc) continue;
        try {
          const s = new XMLSerializer().serializeToString(meta.xmlDoc);
          const cleaned = s
            .replace(/\s+w:rsidR="[^"]*"/g,"")
            .replace(/\s+w:rsidRDefault="[^"]*"/g,"")
            .replace(/\s+w:rsidP="[^"]*"/g,"")
            .replace(/\s+w:rsidDel="[^"]*"/g,"")
            .replace(/\s+w:rsidRPr="[^"]*"/g,"");
          const re = new DOMParser().parseFromString(cleaned,"text/xml");
          meta.xmlDoc = re;
          partsIndex.set(meta.path, meta);
          if (meta.path === "word/document.xml") mainDocXml = re;
        } catch {}
      }

      alert("Metadata wiped (loaded parts).");
      if (currentTab === "parts") renderPart(activePartPath);
    }

    function prepareGhost(docXml) {
      ghostParagraphs = [];
      ghostSelIdx = -1;
      dom.ghostRender.textContent = "";

      const ps = qAll(docXml, "p");
      for (let i=0;i<ps.length;i++){
        let t = "";
        for (const r of qAll(ps[i],"r")) for (const tx of qAll(r,"t")) t += tx.textContent || "";
        ghostParagraphs.push({ node: ps[i], txt: t });

        if (t.trim()) {
          const p = document.createElement("p");
          p.dataset.idx = String(i);
          p.textContent = t;
          dom.ghostRender.appendChild(p);
        }
      }
      ghostReady = true;
    }

    function handleGhostSelection() {
      const sel = window.getSelection();
      if (!sel || sel.isCollapsed || !sel.anchorNode) return;

      let el = sel.anchorNode.nodeType === Node.TEXT_NODE ? sel.anchorNode.parentElement : sel.anchorNode;
      while (el && el !== dom.ghostRender && !el.dataset?.idx) el = el.parentElement;

      if (el && el.dataset && el.dataset.idx != null) {
        ghostSelIdx = parseInt(el.dataset.idx, 10);
        dom.ghostTools.style.display = "block";
        dom.ghostHint.style.display = "none";
        const s = sel.toString();
        dom.ghostSelText.textContent = s.length > 60 ? s.slice(0,60) + "‚Ä¶" : s;
        dom.ghostReplace.value = "";
        if (!dom.ghostAuth.value) dom.ghostAuth.value = "Author";
      }
    }

    function executeGhostEdit() {
      if (ghostSelIdx === -1) { alert("Select text first"); return; }
      const selection = window.getSelection();
      const selTxt = selection ? selection.toString() : "";
      if (!selTxt) { alert("Select text first"); return; }

      const repTxt = dom.ghostReplace.value || "";
      const auth = (dom.ghostAuth.value || "").trim() || "Author";
      const dateIso = dom.ghostDate.value ? fromDatetimeLocal(dom.ghostDate.value) : new Date().toISOString();

      const pObj = ghostParagraphs[ghostSelIdx];
      const pNode = pObj.node;
      const fullTxt = pObj.txt;

      const start = fullTxt.indexOf(selTxt);
      if (start === -1) { alert("Match Error: Try selecting plain text (no line breaks)."); return; }

      const pre = fullTxt.substring(0, start);
      const post = fullTxt.substring(start + selTxt.length);

      const pPr = Array.from(pNode.childNodes).find(n => n.localName === "pPr") || null;
      Array.from(pNode.childNodes).forEach(ch => { if (!(pPr && ch===pPr)) pNode.removeChild(ch); });
      if (pPr && pNode.firstChild !== pPr) pNode.insertBefore(pPr, pNode.firstChild);

      function makeRun(text, kind) {
        const r = mainDocXml.createElementNS(W_NS, "w:r");
        const t = mainDocXml.createElementNS(W_NS, "w:" + kind);
        setAttrXmlSpacePreserve(t, text);
        t.textContent = text;
        r.appendChild(t);
        return r;
      }
      function wrapChange(type, text) {
        if (!text) return null;
        const wrap = mainDocXml.createElementNS(W_NS, type === "del" ? "w:del" : "w:ins");
        const id = String(nextChangeId++);
        setAttrW(wrap, "id", id);
        setAttrW(wrap, "author", auth);
        setAttrW(wrap, "date", dateIso);
        const run = makeRun(text, type === "del" ? "delText" : "t");
        wrap.appendChild(run);
        return wrap;
      }
      function appendNormal(text) { if (!text) return; pNode.appendChild(makeRun(text, "t")); }

      appendNormal(pre);
      const delWrap = wrapChange("del", selTxt);
      if (delWrap) pNode.appendChild(delWrap);
      const insWrap = repTxt ? wrapChange("ins", repTxt) : null;
      if (insWrap) pNode.appendChild(insWrap);
      appendNormal(post);

      const meta = partsIndex.get("word/document.xml");
      if (meta) { meta.loaded = true; meta.xmlDoc = mainDocXml; meta.dirty = true; partsIndex.set("word/document.xml", meta); }

      rebuildRevisionsAndAnchorsFromLoadedParts();
      renderMainTableBody();
      if (currentTab === "parts") renderPart(activePartPath);

      prepareGhost(mainDocXml);
      alert("Injected.");
    }

    function buildRevisionNodeIndex(doc) {
      const idx = new Map();
      for (const n of qAll(doc,"ins")) idx.set("ins:" + attrW(n,"id"), n);
      for (const n of qAll(doc,"del")) idx.set("del:" + attrW(n,"id"), n);
      return idx;
    }

    function ensureSingleTextNode(revEl, kindLocalName, text) {
      const nodes = qAll(revEl, kindLocalName);
      if (nodes.length > 0) {
        nodes[0].textContent = text;
        setAttrXmlSpacePreserve(nodes[0], text);
        for (let i = nodes.length - 1; i >= 1; i--) nodes[i].parentNode && nodes[i].parentNode.removeChild(nodes[i]);
      } else {
        const r = revEl.ownerDocument.createElementNS(W_NS, "w:r");
        const t = revEl.ownerDocument.createElementNS(W_NS, "w:" + kindLocalName);
        setAttrXmlSpacePreserve(t, text);
        t.textContent = text;
        r.appendChild(t);
        revEl.appendChild(r);
      }
    }

    function applyEditsToLoadedPartsRevisions() {
      const partIndexes = new Map();
      for (const meta of partsIndex.values()) {
        if (!meta.loaded || !meta.xmlDoc) continue;
        partIndexes.set(meta.path, buildRevisionNodeIndex(meta.xmlDoc));
      }

      for (const it of items.values()) {
        if (it.type !== "ins" && it.type !== "del") continue;
        const p = it.part;
        const meta = partsIndex.get(p);
        if (!meta || !meta.loaded || !meta.xmlDoc) continue;
        const idx = partIndexes.get(p);
        if (!idx) continue;

        const node = idx.get(it.type + ":" + it.id);
        if (!node) continue;

        setAttrW(node, "author", it.auth || "");
        if (it.date) setAttrW(node, "date", it.date);

        if (it.type === "ins") ensureSingleTextNode(node, "t", it.txt || "");
        else ensureSingleTextNode(node, "delText", it.txt || "");
      }
    }

    async function applyEditsToCommentsXmlAndWrite(zip) {
      if (!zip.file("word/comments.xml")) return false;

      const dirty = [];
      for (const it of items.values()) {
        if (it && it.type === "com" && (it._dirtyMeta || it._dirtyText)) dirty.push(it);
      }
      if (dirty.length === 0) return false;

      const s = await zip.file("word/comments.xml").async("string");
      const cDoc = new DOMParser().parseFromString(s, "text/xml");
      if (isParserError(cDoc)) throw new Error("Failed to parse comments.xml");

      const map = new Map();
      for (const c of qAll(cDoc, "comment")) map.set(attrW(c, "id"), c);

      for (const it of dirty) {
        const n = map.get(it.id);
        if (!n) continue;

        // Only update metadata if the user actually changed it.
        if (it._dirtyMeta) {
          setAttrW(n, "author", it.auth || "");
          if (it.date) setAttrW(n, "date", it.date);
        }

        // Only rewrite the comment body if the user edited the text.
        if (it._dirtyText) {
          const ps = Array.from(n.childNodes).filter(ch => ch && ch.nodeType === 1 && ch.localName === "p");
          for (const p of ps) n.removeChild(p);

          const p = cDoc.createElementNS(W_NS, "w:p");
          const r = cDoc.createElementNS(W_NS, "w:r");
          const t = cDoc.createElementNS(W_NS, "w:t");
          setAttrXmlSpacePreserve(t, it.txt || "");
          t.textContent = it.txt || "";
          r.appendChild(t);
          p.appendChild(r);
          n.appendChild(p);
        }
      }

      zip.file("word/comments.xml", new XMLSerializer().serializeToString(cDoc));
      return true;
    }

    
    async function applyPendingGlobalMetaOpsToZip(zip) {
      if (!zip || !pendingGlobalMetaOps || pendingGlobalMetaOps.length === 0) return;

      const paths = Object.keys(zip.files || {}).filter(p => p.startsWith("word/") && p.endsWith(".xml"));
      if (paths.length === 0) return;

      // Precompute setAuthor target (if any) ‚Äî last one wins.
      let lastSetAuthor = null;
      for (const op of pendingGlobalMetaOps) {
        if (op && op.op === "setAuthor") lastSetAuthor = String(op.to || "").trim();
      }
      const setAuthorEsc = (lastSetAuthor != null) ? escapeXmlAttr(lastSetAuthor) : null;

      for (const path of paths) {
        const f = zip.file(path);
        if (!f) continue;

        let s;
        try { s = await f.async("string"); }
        catch { continue; }

        let out = s;

        // Apply ops in the order they were added
        for (const op of pendingGlobalMetaOps) {
          if (!op) continue;
          if (op.op === "replaceAuthor") {
            out = patchAuthorAttrsInXml(out, op.fromRaw, op.to);
          } else if (op.op === "setAuthor") {
            if (setAuthorEsc == null) continue;
            out = out.replace(/\bw:author\s*=\s*(["'])(.*?)(\1)/g, (m, q, val) => m.replace(val, setAuthorEsc));
          }
        }

        if (out !== s) zip.file(path, out);
      }
    }

async function downloadWord() {
      if (!zipObj) return;
      setStatus("Saving‚Ä¶", true);

      await ensurePartLoaded("word/document.xml");

      const dirtyParts = new Set();
      const patchedParts = new Set();
      const byPart = new Map();

      for (const it of items.values()) {
        if (!it || !(it._dirtyMeta || it._dirtyText)) continue;
        if (it.type === "ins" || it.type === "del") {
          const p = it.part || "word/document.xml";
          if (!byPart.has(p)) byPart.set(p, []);
          byPart.get(p).push(it);
        }
      }

      for (const [p, list] of byPart.entries()) {
        if (!partsIndex.has(p)) continue;
        await ensurePartLoaded(p);
        const meta = partsIndex.get(p);
        if (!meta || !meta.loaded || !meta.xmlDoc) continue;

        const idx = buildRevisionNodeIndex(meta.xmlDoc);
        for (const it of list) {
          const node = idx.get(it.type + ":" + it.id);
          if (!node) continue;

          // Author/date edits should never rewrite the underlying content structure.
          if (it._dirtyMeta) {
            setAttrW(node, "author", it.auth || "");
            if (it.date) setAttrW(node, "date", it.date);
          }

          // Text edits: only update existing text nodes; never create new ones.
          if (it._dirtyText) {
            const kind = (it.type === "ins") ? "t" : "delText";
            const nodes = qAll(node, kind);
            if (nodes.length > 0) {
              nodes[0].textContent = it.txt || "";
              setAttrXmlSpacePreserve(nodes[0], it.txt || "");
              for (let i = 1; i < nodes.length; i++) {
                nodes[i].textContent = "";
                setAttrXmlSpacePreserve(nodes[i], "");
              }
            }
          }
        }

        const hasTextEdits = list.some(x => x && x._dirtyText);

        if (!hasTextEdits) {
          // Avoid serializing whole XML for metadata-only changes; patch the original XML string in-place
          // so we don‚Äôt accidentally perturb numbering / formatting structures.
          let xmlStr = meta.original;
          for (const it of list) {
            if (!it || !it._dirtyMeta) continue;
            xmlStr = patchRevisionAttrsInXml(xmlStr, it.type, it.id, it.auth || "", it.date || "");
          }
          meta.original = xmlStr;
          zipObj.file(meta.path, xmlStr);
          meta.dirty = false;
          patchedParts.add(meta.path);
          partsIndex.set(p, meta);
        } else {
          meta.dirty = true;
          partsIndex.set(p, meta);
          dirtyParts.add(p);
        }
      }

      const commentsWrote = await applyEditsToCommentsXmlAndWrite(zipObj);
      writeMetaBackToZip();

      const ser = new XMLSerializer();
      for (const meta of partsIndex.values()) {
        if (!meta || !meta.loaded || !meta.xmlDoc) continue;
        if (patchedParts && patchedParts.has(meta.path)) continue;
        if (!meta.dirty) continue;
        zipObj.file(meta.path, ser.serializeToString(meta.xmlDoc));
      }
      if (commentsWrote) {  }

      await applyPendingGlobalMetaOpsToZip(zipObj);

      const blob = await zipObj.generateAsync({ type:"blob", compression:"DEFLATE", compressionOptions:{ level:6 } });
      saveAs(blob, "Edited_" + (originalFileName || "document.docx"));
      setStatus("Saved!", true);
    }


    function getUniqueAuthors() {
      const set = new Set();
      for (const it of items.values()) {
        const a = (it && typeof it.auth === "string") ? it.auth.trim() : "";
        if (a) set.add(a);
      }
      return Array.from(set).sort((a,b)=>a.localeCompare(b));
    }

    function populateBatchAuthorDropdowns() {
      if (!dom.btFromAuthor) return;

      const authors = getUniqueAuthors();

      dom.btFromAuthor.textContent = "";
      const optBlank = document.createElement("option");
      optBlank.value = "__blank__";
      optBlank.textContent = "(blank)";
      dom.btFromAuthor.appendChild(optBlank);

      for (const a of authors) {
        const opt = document.createElement("option");
        opt.value = a;
        opt.textContent = a;
        dom.btFromAuthor.appendChild(opt);
      }
    }

    function openBatchTools(){ populateBatchAuthorDropdowns(); dom.btModal.style.display="block"; dom.btModal.setAttribute("aria-hidden","false"); refreshBatchUi(); }
    function closeBatchTools(){ dom.btModal.style.display="none"; dom.btModal.setAttribute("aria-hidden","true"); }

    function refreshBatchUi() {
      const op = dom.btOp.value;
      btRows.author.style.display = (op==="setAuthor") ? "block" : "none";
      btRows.replace.style.display = (op==="replaceAuthor") ? "block" : "none";
      btRows.date.style.display = (op==="setDate") ? "block" : "none";
      btRows.seq.style.display = (op==="sequentialDate") ? "block" : "none";
      btRows.shift.style.display = (op==="shiftDate") ? "block" : "none";
    }

    function getBatchCandidateRows(scope) {
      let rows;
      if (scope === "filtered") rows = getProcessedMainData().map(r => items.get(r.uid)).filter(Boolean);
      else if (scope === "selected") rows = Array.from(selectedUids).map(uid => items.get(uid)).filter(Boolean);
      else rows = Array.from(items.values());

      rows = rows.filter(x => x && (x.type==="com" || x.type==="ins" || x.type==="del"));
      return rows;
    }

    function batchFilter(rows) {
      const wantCom = dom.btCom.checked;
      const wantIns = dom.btIns.checked;
      const wantDel = dom.btDel.checked;
      const part = dom.btPart.value;

      return rows.filter(x => {
        if (x.type==="com" && !wantCom) return false;
        if (x.type==="ins" && !wantIns) return false;
        if (x.type==="del" && !wantDel) return false;
        if (part !== "*" && (x.part || "") !== part) return false;
        return true;
      });
    }

    function batchOrder(rows, scope) {
      if (scope === "filtered") {
        const visible = getProcessedMainData().map(r => r.uid);
        const pos = new Map();
        visible.forEach((u,i)=>pos.set(u,i));
        return stableSort(rows, (a,b)=> (pos.get(a.uid) ?? 1e9) - (pos.get(b.uid) ?? 1e9));
      }
      return stableSort(rows, (a,b) => {
        const pa = String(a.part||""), pb = String(b.part||"");
        if (pa < pb) return -1;
        if (pa > pb) return 1;
        const ga = Number(a.pg)||0, gb = Number(b.pg)||0;
        if (ga !== gb) return ga - gb;
        return String(a.uid).localeCompare(String(b.uid));
      });
    }

    function applyBatchTools() {
      const scope = dom.btScope.value;
      const op = dom.btOp.value;

      let rows = batchOrder(batchFilter(getBatchCandidateRows(scope)), scope);

      if (rows.length === 0) { alert("No matching items for that scope/type/part."); return; }

      if (op === "setAuthor") {
        const a = (dom.btAuthor.value || "").trim();
        if (!a) { alert("Enter an author."); return; }
        rows.forEach(x => { x.auth = a; x._dirtyMeta = true; });
        pendingGlobalMetaOps.push({ op:"setAuthor", to:a });
      }

      if (op === "replaceAuthor") {
        const fromRaw = dom.btFromAuthor.value;
        const from = (fromRaw === "__blank__") ? "" : String(fromRaw || "").trim();

        const to = String(dom.btToAuthor?.value || "").trim();
        if (!to) { alert("Enter a ‚ÄòTo‚Äô author."); return; }

        if (fromRaw == null || fromRaw === "") { alert("Pick a From author."); return; }

        const fromLC = from.toLowerCase();
        rows.forEach(x => {
          const cur = String(x.auth || "").trim();
          const curLC = cur.toLowerCase();
          if (fromRaw === "__blank__") {
            if (!cur) { x.auth = to; x._dirtyMeta = true; }
          } else {
            if (curLC === fromLC) { x.auth = to; x._dirtyMeta = true; }
          }
        });
        pendingGlobalMetaOps.push({ op:"replaceAuthor", fromRaw:fromRaw, from:from, to:to });
      }

if (op === "setDate") {
        const iso = fromDatetimeLocal(dom.btDt.value);
        if (!iso) { alert("Pick a date/time."); return; }
        rows.forEach(x => { x.date = iso; x._dirtyMeta = true; });
      }

      if (op === "sequentialDate") {
        const startIso = fromDatetimeLocal(dom.btSeqStart.value);
        const step = Number(dom.btSeqStep.value);
        if (!startIso || isNaN(step) || step < 0) { alert("Pick a start date/time and valid step."); return; }
        let d = new Date(startIso);
        rows.forEach(x => { x.date = d.toISOString(); x._dirtyMeta = true; d.setMinutes(d.getMinutes() + step); });
      }

      if (op === "shiftDate") {
        const amt = Number(dom.btShiftAmt.value);
        if (isNaN(amt) || amt === 0) { alert("Enter a non-zero shift amount."); return; }
        const unit = dom.btShiftUnit.value;
        let ms = amt * 60 * 1000;
        if (unit === "hours") ms = amt * 60 * 60 * 1000;
        if (unit === "days") ms = amt * 24 * 60 * 60 * 1000;

        rows.forEach(x => {
          if (!x.date) return;
          const d = new Date(x.date);
          if (isNaN(d.getTime())) return;
          d.setTime(d.getTime() + ms);
          x.date = d.toISOString(); x._dirtyMeta = true;
        });
      }

      renderMainTableBody();
      if (currentTab === "parts") renderSidebarForPart(activePartPath);
      closeBatchTools();
      alert("Batch applied to " + rows.length + " item(s).");
    }

    async function switchTab(t) {
      currentTab = t;
      if (t === "comments" || t === "revisions" || t === "all") activityMode = t;

      document.querySelectorAll(".view-section").forEach(e => e.style.display="none");
      document.querySelectorAll(".tab-btn").forEach(e => e.classList.remove("active"));
      const btn = document.querySelector(`.tab-btn[data-tab="${t}"]`);
      if (btn) btn.classList.add("active");

      if (t === "relationships") {
        dom.viewRel.style.display="block";
        if (!relationshipsBuilt) {
          await buildRelationshipsOnDemand();
        } else {
          renderRelTable();
        }
      } else if (t === "forensics") {
        dom.viewForensics.style.display="block";
        renderForensicsBody();
      } else if (t === "parts") {
        dom.viewParts.style.display="block";
        if (!partsIndex.has(activePartPath)) activePartPath = "word/document.xml";
        await ensurePartLoaded(activePartPath);
        renderPart(activePartPath);
      } else if (t === "ghost") {
        dom.viewGhost.style.display="block";
        if (!ghostReady) {
          await ensurePartLoaded("word/document.xml");
          setStatus("Preparing Ghost Writer‚Ä¶", true);
          await yieldToUI();
          prepareGhost(mainDocXml);
          setStatus("Ready.", true);
        }
      } else if (t === "regex") {
        dom.viewRegex.style.display="block";
        renderRegexBody();
      } else if (t === "meta") {
        dom.viewMeta.style.display="block";
      } else {
        dom.viewTable.style.display="block";
        renderMainTableBody();
      }

      refreshExportButtons();
    }

    async function loadFile(file) {
      if (!file) return;
      clearErrorLog();

      originalFileName = file.name;
      setStatus("Loading‚Ä¶", true);

      try {
        const buf = await file.arrayBuffer();
        zipObj = await JSZip.loadAsync(buf);

        try {
          if (zipObj.file("word/settings.xml")) {
            let s = await zipObj.file("word/settings.xml").async("string");
            s = s
              .replace(/<w:documentProtection\b[^>]*\/>/g, "")
              .replace(/<w:writeProtection\b[^>]*\/>/g, "")
              .replace(/<w:documentProtection\b[^>]*>[\s\S]*?<\/w:documentProtection>/g, "")
              .replace(/<w:writeProtection\b[^>]*>[\s\S]*?<\/w:writeProtection>/g, "");
            zipObj.file("word/settings.xml", s);
          }
        } catch {}

        buildPartsIndex(zipObj);
        populatePartSelects();

        await ensurePartLoaded("word/document.xml");

        commentsXmlDoc = null;
        if (zipObj.file("word/comments.xml")) {
          const cStr = await zipObj.file("word/comments.xml").async("string");
          commentsXmlDoc = new DOMParser().parseFromString(cStr, "text/xml");
          if (isParserError(commentsXmlDoc)) throw new Error("Failed to parse word/comments.xml");
        }

        coreXmlDoc = null; appXmlDoc = null;
        if (zipObj.file("docProps/core.xml")) {
          const s = await zipObj.file("docProps/core.xml").async("string");
          coreXmlDoc = new DOMParser().parseFromString(s, "text/xml");
          if (isParserError(coreXmlDoc)) coreXmlDoc = null;
        }
        if (zipObj.file("docProps/app.xml")) {
          const s = await zipObj.file("docProps/app.xml").async("string");
          appXmlDoc = new DOMParser().parseFromString(s, "text/xml");
          if (isParserError(appXmlDoc)) appXmlDoc = null;
        }
        populateMeta();

        buildInitialActivityFast();

        relationshipsBuilt = false;
        relationshipsData = [];
        relHeadBuilt = false;
        dom.relHead.textContent = "";
        dom.relBody.textContent = "";

        ghostReady = false;
        ghostParagraphs = [];
        dom.ghostRender.textContent = "";
        dom.ghostTools.style.display = "none";
        dom.ghostHint.style.display = "block";

        dom.drop.style.display="none";
        dom.toolbar.style.display="flex";
        dom.tabs.style.display="flex";

        setStatus("Loaded. (Relationships and other parts load on demand.)", true);
        await switchTab("all");
      } catch (e) {
        console.error(e);
        setStatus("Error loading file", false);
        alert("Error: " + (e.message || e));
      }
    }

    function wireUi() {
      if (typeof JSZip === "undefined" || typeof XLSX === "undefined" || typeof saveAs === "undefined") {
        setStatus("Missing required libraries (jszip.min.js / xlsx.full.min.js / FileSaver.min.js).", false);
        alert("Missing required libraries. Make sure jszip.min.js, xlsx.full.min.js, and FileSaver.min.js are in the same folder as this HTML file.");
        return;
      }
      dom.drop.addEventListener("click", () => dom.file.click());
      dom.drop.addEventListener("keydown", (e) => { if (e.key==="Enter" || e.key===" ") dom.file.click(); });
      dom.file.addEventListener("change", (e) => loadFile(e.target.files[0]));

      ["dragenter","dragover"].forEach(evt => dom.drop.addEventListener(evt, (e)=>{ e.preventDefault(); e.stopPropagation(); dom.drop.classList.add("dragover"); }));
      ["dragleave","drop"].forEach(evt => dom.drop.addEventListener(evt, (e)=>{ e.preventDefault(); e.stopPropagation(); dom.drop.classList.remove("dragover"); }));
      dom.drop.addEventListener("drop", (e)=>{ const f = e.dataTransfer?.files?.[0]; if (f) loadFile(f); });

      dom.tabs.addEventListener("click", async (e) => {
        const btn = e.target.closest(".tab-btn");
        if (!btn) return;
        await switchTab(btn.dataset.tab);
      });

      document.getElementById("btn-save").addEventListener("click", downloadWord);
      document.getElementById("btn-reset").addEventListener("click", () => location.reload());
      document.getElementById("btn-batch-tools").addEventListener("click", openBatchTools);

      dom.btnCopy.addEventListener("click", copyCurrentTab);
      dom.btnExport.addEventListener("click", exportCurrentTabXlsx);

      dom.partSelect.addEventListener("change", async () => { await setActivePart(dom.partSelect.value); });
      dom.partFilter.addEventListener("input", () => { if (currentTab === "parts") renderSidebarForPart(activePartPath); });
      document.getElementById("btn-clear-selection").addEventListener("click", () => { selectedUids.clear(); if (currentTab!=="relationships") renderMainTableBody(); alert("Selection cleared."); });
      document.getElementById("btn-scan").addEventListener("click", scanForensics);

      document.getElementById("btn-wipe").addEventListener("click", wipeMetadata);

      dom.ghostRender.addEventListener("mouseup", handleGhostSelection);
      dom.ghostRender.addEventListener("touchend", () => setTimeout(handleGhostSelection, 0));
      document.addEventListener("selectionchange", () => { if (dom.viewGhost.style.display === "block") handleGhostSelection(); });
      document.getElementById("btn-inject").addEventListener("click", executeGhostEdit);

      document.getElementById("btn-bt-cancel").addEventListener("click", closeBatchTools);
      document.getElementById("btn-bt-apply").addEventListener("click", applyBatchTools);
      dom.btModal.addEventListener("click", (e)=>{ if (e.target === dom.btModal) closeBatchTools(); });
      dom.btOp.addEventListener("change", refreshBatchUi);

      refreshExportButtons();
    }

    window.addEventListener("DOMContentLoaded", wireUi);
  </script>
</body>
</html>r
